# ADR-009: Event Consolidation — Strangler Fig Completion

**Status:** Accepted
**Date:** 2026-02-16
**Decision Makers:** Engineering Team
**Supersedes:** Partial — extends ADR-014 Phase 2

## Context

Cycle-030 introduced two parallel event systems:

1. **BillingEventEmitter** → `billing_events` table (27 event types, dual-write pattern, ADR-014)
2. **EconomicEventEmitter** → `economic_events` outbox table (29 event types, outbox pattern with async dispatch)

Both persist events within the same SQLite transaction as the primary write. Both are append-only. But they write to different tables with different schemas, creating operational friction:

- New code must choose which emitter to use
- Consumers must query two tables for a complete event picture
- ReconciliationService uses `as any` casts to bridge the type gap (BB-67-009)
- The 29 economic event types and 27 billing event types overlap but don't fully align

The relationship between the two systems is unclear: is `economic_events` an extension of `billing_events`, or its replacement?

## Decision

**EventConsolidationAdapter as a Strangler Fig dual-write bridge.**

### Architecture

```
Caller
  │
  ▼
EventConsolidationAdapter (implements IEconomicEventEmitter)
  ├── EconomicEventEmitter.emitInTransaction(tx, event)  ← authoritative
  └── BillingEventEmitter.emit(billingEvent, { db: tx }) ← legacy compat
```

New code emits through `EventConsolidationAdapter`. The adapter:
1. **Always** writes to `economic_events` (authoritative path)
2. **Conditionally** writes to `billing_events` (legacy path, only for mapped types)

### Event Type Mapping

| Category | Count | Behavior |
|----------|-------|----------|
| Direct 1:1 mapping | 21 types | Written to BOTH tables |
| Economic-only | 16 types | Written to `economic_events` only |
| Billing-only (unmapped) | 6 types | Written to `billing_events` only via `emitLegacyOnly()` |

**Mapped types (21):** LotMinted, ReservationCreated, ReservationFinalized, ReservationReleased, ReferralRegistered, BonusGranted, BonusFlagged, EarningRecorded, EarningSettled, EarningClawedBack, AgentSettlementInstant, AgentClawbackPartial, AgentClawbackReceivableCreated, AgentBudgetWarning, AgentBudgetExhausted, PayoutRequested, PayoutApproved, PayoutCompleted, PayoutFailed, RewardsDistributed, ScoreImported

**Economic-only (16):** ConfigProposed, ConfigApproved, ConfigActivated, ReconciliationCompleted, ReconciliationDivergence, PeerTransferInitiated, PeerTransferCompleted, PeerTransferRejected, TbaBound, TbaDepositDetected, TbaDepositBridged, TbaDepositFailed, AgentProposalSubmitted, AgentProposalQuorumReached, AgentProposalActivated, AgentProposalRejected

**Billing-only (6):** AccountCreated, LotExpired, BonusWithheld, PayoutProcessing, WalletLinked, WalletUnlinked

### Field Mapping (EconomicEventInput → BillingEvent)

| EconomicEventInput | BillingEvent | Notes |
|-------------------|--------------|-------|
| `eventType` | `type` | Same string for mapped types |
| `entityType` | `aggregateType` | Cast to AggregateType union |
| `entityId` | `aggregateId` | Direct mapping |
| `correlationId` | `causationId` | Nullable in both |
| `payload` | `payload` | Same structure |
| — | `timestamp` | Auto-generated by BillingEventEmitter |

### Query Delegation

During the transition period, `getEventsForAggregate()` and `getBalanceAtTime()` delegate to the legacy `BillingEventEmitter`. Consumers continue reading from `billing_events` without modification.

### Deprecation Marker

Migration 059 adds a nullable `deprecated_at` column to `billing_events`. This is a future-use marker — the adapter does not populate it. Future tooling can use it to mark rows that have been superseded by their `economic_events` counterparts.

## Payload Schema Compatibility

Consumers of `billing_events` can rely on:

1. **Stable type strings** — event type names do not change
2. **Stable payload keys** — existing payload fields are never removed or renamed
3. **Additive extensions only** — new payload fields may be added but existing ones preserved
4. **Consistent serialization** — payload is always JSON.stringify'd

## Removal Timeline

`BillingEventEmitter` can be removed when ALL of:

1. All query consumers have migrated from `billing_events` to `economic_events`
2. Temporal queries (getBalanceAtTime) have been reimplemented against `economic_events`
3. The `deprecated_at` marker has been set on all historical rows (optional)
4. A full reconciliation run confirms parity between the two tables

**No timeline is set.** The dual-write has negligible performance cost (same SQLite transaction, same WAL). Removal is driven by consumer migration, not urgency.

## Migration Checklist for Consumer Teams

- [ ] Replace `BillingEventEmitter` constructor injection with `EventConsolidationAdapter`
- [ ] Replace `getEventsForAggregate()` calls with `economic_events` queries (future)
- [ ] Replace `getBalanceAtTime()` with economic_events-based temporal query (future)
- [ ] Remove `as any` casts in event emission code (ReconciliationService: done)
- [ ] Update integration tests to verify dual-write behavior

## Alternatives Considered

### 1. Drop billing_events immediately
Rejected: breaks all existing consumers, temporal queries, and the ReconciliationService.

### 2. Database-level trigger for dual-write
Rejected: SQLite triggers add complexity, are harder to test, and don't support the field mapping needed between the two schemas.

### 3. Keep both systems independent
Rejected: increases cognitive load, creates type-safety gaps (`as any`), and makes it unclear which system is authoritative.

## Consequences

**Positive:**
- Single entry point for event emission (EventConsolidationAdapter)
- Zero `as any` casts in event emission code
- Clear authoritative path (economic_events) with documented legacy compat
- Existing consumers unaffected during transition

**Negative:**
- Two tables store overlapping data (temporary, by design)
- Slight increase in write amplification for mapped types (two INSERTs per event)
- EventConsolidationAdapter is an additional abstraction layer

**Risks:**
- Consumer migration may stall if there's no pressure to move off billing_events
- The mapping table must be updated if new billing event types are added
