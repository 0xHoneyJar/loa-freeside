{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Found missing tenant isolation on outbox/DLQ/verification tables and incomplete immutability protections on audit-sensitive fields.",
  "issues": [
    {
      "severity": "critical",
      "file": "migration_0017.sql",
      "line": 86,
      "description": "No Row-Level Security on governance_outbox allows cross-tenant reads/writes, violating multi-tenant isolation.",
      "current_code": "```sql\nCREATE TABLE IF NOT EXISTS governance_outbox (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    community_id UUID NOT NULL REFERENCES communities(id),\n    policy_id UUID NOT NULL REFERENCES economic_policies(id),\n    policy_version INTEGER NOT NULL,\n    action TEXT NOT NULL,\n    payload JSONB NOT NULL,\n    processed_at TIMESTAMPTZ,\n    attempts INTEGER NOT NULL DEFAULT 0,\n    last_error TEXT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n```",
      "fixed_code": "```sql\nCREATE TABLE IF NOT EXISTS governance_outbox (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    community_id UUID NOT NULL REFERENCES communities(id),\n    policy_id UUID NOT NULL REFERENCES economic_policies(id),\n    policy_version INTEGER NOT NULL,\n    action TEXT NOT NULL,\n    payload JSONB NOT NULL,\n    processed_at TIMESTAMPTZ,\n    attempts INTEGER NOT NULL DEFAULT 0,\n    last_error TEXT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nALTER TABLE governance_outbox ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY governance_outbox_select\n    ON governance_outbox\n    FOR SELECT\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY governance_outbox_insert\n    ON governance_outbox\n    FOR INSERT\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY governance_outbox_update\n    ON governance_outbox\n    FOR UPDATE\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ))\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n```",
      "explanation": "Enables RLS and applies the same tenant-bound policy pattern to prevent any cross-tenant access or mutation of the outbox."
    },
    {
      "severity": "critical",
      "file": "migration_0017.sql",
      "line": 122,
      "description": "No Row-Level Security on governance_outbox_dlq allows cross-tenant reads/writes of dead letter records.",
      "current_code": "```sql\nCREATE TABLE IF NOT EXISTS governance_outbox_dlq (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    original_outbox_id UUID NOT NULL,\n    community_id UUID NOT NULL,\n    policy_id UUID NOT NULL,\n    policy_version INTEGER NOT NULL,\n    action TEXT NOT NULL,\n    payload JSONB NOT NULL,\n    attempts INTEGER NOT NULL,\n    last_error TEXT,\n    moved_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n```",
      "fixed_code": "```sql\nCREATE TABLE IF NOT EXISTS governance_outbox_dlq (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    original_outbox_id UUID NOT NULL,\n    community_id UUID NOT NULL,\n    policy_id UUID NOT NULL,\n    policy_version INTEGER NOT NULL,\n    action TEXT NOT NULL,\n    payload JSONB NOT NULL,\n    attempts INTEGER NOT NULL,\n    last_error TEXT,\n    moved_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nALTER TABLE governance_outbox_dlq ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY governance_outbox_dlq_select\n    ON governance_outbox_dlq\n    FOR SELECT\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY governance_outbox_dlq_insert\n    ON governance_outbox_dlq\n    FOR INSERT\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY governance_outbox_dlq_update\n    ON governance_outbox_dlq\n    FOR UPDATE\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ))\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n```",
      "explanation": "Applies tenant isolation to DLQ rows to prevent data leakage or mutation across communities."
    },
    {
      "severity": "critical",
      "file": "migration_0017.sql",
      "line": 139,
      "description": "No Row-Level Security on community_verification_jobs allows cross-tenant access to verification job data.",
      "current_code": "```sql\nCREATE TABLE IF NOT EXISTS community_verification_jobs (\n    job_id TEXT PRIMARY KEY,\n    community_id UUID NOT NULL,\n    status TEXT NOT NULL DEFAULT 'pending',\n    result JSONB,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    completed_at TIMESTAMPTZ\n);\n```",
      "fixed_code": "```sql\nCREATE TABLE IF NOT EXISTS community_verification_jobs (\n    job_id TEXT PRIMARY KEY,\n    community_id UUID NOT NULL,\n    status TEXT NOT NULL DEFAULT 'pending',\n    result JSONB,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    completed_at TIMESTAMPTZ\n);\n\nALTER TABLE community_verification_jobs ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY community_verification_jobs_select\n    ON community_verification_jobs\n    FOR SELECT\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY community_verification_jobs_insert\n    ON community_verification_jobs\n    FOR INSERT\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n\nCREATE POLICY community_verification_jobs_update\n    ON community_verification_jobs\n    FOR UPDATE\n    USING (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ))\n    WITH CHECK (community_id = COALESCE(\n        NULLIF(current_setting('app.community_id', true), '')::uuid,\n        '00000000-0000-0000-0000-000000000000'::uuid\n    ));\n```",
      "explanation": "Ensures verification job rows are only accessible to the current tenant, eliminating cross-tenant read/write risk."
    },
    {
      "severity": "major",
      "file": "migration_0017.sql",
      "line": 63,
      "description": "Immutability trigger only protects proposed_by and approved_at; other audit-sensitive fields can be mutated, breaking audit integrity.",
      "current_code": "```sql\nCREATE OR REPLACE FUNCTION prevent_policy_field_mutation()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF OLD.proposed_by IS DISTINCT FROM NEW.proposed_by THEN\n        RAISE EXCEPTION 'Cannot mutate proposed_by on economic_policies';\n    END IF;\n    IF OLD.approved_at IS NOT NULL AND OLD.approved_at IS DISTINCT FROM NEW.approved_at THEN\n        RAISE EXCEPTION 'Cannot mutate approved_at once set on economic_policies';\n    END IF;\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n```",
      "fixed_code": "```sql\nCREATE OR REPLACE FUNCTION prevent_policy_field_mutation()\nRETURNS TRIGGER AS $$\nBEGIN\n    -- Immutable identity/audit fields\n    IF OLD.community_id IS DISTINCT FROM NEW.community_id THEN\n        RAISE EXCEPTION 'Cannot mutate community_id on economic_policies';\n    END IF;\n    IF OLD.policy_type IS DISTINCT FROM NEW.policy_type THEN\n        RAISE EXCEPTION 'Cannot mutate policy_type on economic_policies';\n    END IF;\n    IF OLD.policy_value IS DISTINCT FROM NEW.policy_value THEN\n        RAISE EXCEPTION 'Cannot mutate policy_value on economic_policies';\n    END IF;\n    IF OLD.policy_version IS DISTINCT FROM NEW.policy_version THEN\n        RAISE EXCEPTION 'Cannot mutate policy_version on economic_policies';\n    END IF;\n    IF OLD.proposed_by IS DISTINCT FROM NEW.proposed_by THEN\n        RAISE EXCEPTION 'Cannot mutate proposed_by on economic_policies';\n    END IF;\n    IF OLD.created_at IS DISTINCT FROM NEW.created_at THEN\n        RAISE EXCEPTION 'Cannot mutate created_at on economic_policies';\n    END IF;\n    IF OLD.effective_from IS DISTINCT FROM NEW.effective_from THEN\n        RAISE EXCEPTION 'Cannot mutate effective_from on economic_policies';\n    END IF;\n\n    -- Once-set fields\n    IF OLD.approved_at IS NOT NULL AND OLD.approved_at IS DISTINCT FROM NEW.approved_at THEN\n        RAISE EXCEPTION 'Cannot mutate approved_at once set on economic_policies';\n    END IF;\n    IF OLD.approved_by IS NOT NULL AND OLD.approved_by IS DISTINCT FROM NEW.approved_by THEN\n        RAISE EXCEPTION 'Cannot mutate approved_by once set on economic_policies';\n    END IF;\n\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n```",
      "explanation": "Locks down immutable audit/identity fields and prevents tampering with the original policy definition while still allowing state transitions and timestamps."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1
}
