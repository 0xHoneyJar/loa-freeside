{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Found data leakage risk and missing-table crashes in the conservation endpoint; fixes add table/column guards and scope reconciliation history by community.",
  "issues": [
    {
      "severity": "critical",
      "file": "api/routes/admin-agent.ts",
      "line": 420,
      "description": "Reconciliation run history is not scoped to the community, leaking data across communities if the table contains global runs.",
      "current_code": "```typescript\n      try {\n        const runs = db.prepare(`\n          SELECT id, started_at, finished_at, status, divergence_summary_json\n          FROM reconciliation_runs\n          ORDER BY started_at DESC\n          LIMIT ?\n        `).all(limit) as Array<{\n          id: string;\n          started_at: string;\n          finished_at: string | null;\n          status: string;\n          divergence_summary_json: string | null;\n        }>;\n\n        reconciliationHistory = runs.map(r => {\n          let divergenceSummary: Record<string, unknown> | null = null;\n          if (r.divergence_summary_json) {\n            try {\n              divergenceSummary = JSON.parse(r.divergence_summary_json);\n            } catch {\n              // Malformed JSON — skip\n            }\n          }\n          return {\n            id: r.id,\n            startedAt: r.started_at,\n            finishedAt: r.finished_at,\n            status: r.status,\n            divergenceSummary,\n          };\n        });\n      } catch {\n        // reconciliation_runs table may not exist if migration 055 hasn't run\n      }\n```",
      "fixed_code": "```typescript\n      try {\n        // Only return reconciliation runs scoped to this community\n        if (tableExists(db, 'reconciliation_runs') && tableHasColumn(db, 'reconciliation_runs', 'community_id')) {\n          const runs = db.prepare(`\n            SELECT id, started_at, finished_at, status, divergence_summary_json\n            FROM reconciliation_runs\n            WHERE community_id = ?\n            ORDER BY started_at DESC\n            LIMIT ?\n          `).all(communityId, limit) as Array<{\n            id: string;\n            started_at: string;\n            finished_at: string | null;\n            status: string;\n            divergence_summary_json: string | null;\n          }>;\n\n          reconciliationHistory = runs.map(r => {\n            let divergenceSummary: Record<string, unknown> | null = null;\n            if (r.divergence_summary_json) {\n              try {\n                divergenceSummary = JSON.parse(r.divergence_summary_json);\n              } catch {\n                // Malformed JSON — skip\n              }\n            }\n            return {\n              id: r.id,\n              startedAt: r.started_at,\n              finishedAt: r.finished_at,\n              status: r.status,\n              divergenceSummary,\n            };\n          });\n        } else {\n          reconciliationHistory = [];\n        }\n      } catch {\n        // reconciliation_runs table may not exist if migration 055 hasn't run\n      }\n```",
      "explanation": "Filtering by community_id prevents cross-community leakage. The guard ensures no query runs if the table/column is missing."
    },
    {
      "severity": "major",
      "file": "api/routes/admin-agent.ts",
      "line": 305,
      "description": "Conservation endpoint assumes credit_lots and credit_balances tables always exist; missing migrations will throw and return 500 instead of a safe response.",
      "current_code": "```typescript\n      const lotSummary = db.prepare(`\n        SELECT\n          COUNT(*) as total_lots,\n          COALESCE(SUM(original_micro), 0) as total_created_micro,\n          COALESCE(SUM(consumed_micro), 0) as total_consumed_micro,\n          COALESCE(SUM(available_micro), 0) as total_available_micro,\n          COALESCE(SUM(reserved_micro), 0) as total_reserved_micro\n        FROM credit_lots\n        WHERE account_id IN (${placeholders})\n      `).get(...accountIds) as {\n        total_lots: number;\n        total_created_micro: number;\n        total_consumed_micro: number;\n        total_available_micro: number;\n        total_reserved_micro: number;\n      };\n\n      const cachedBalance = db.prepare(`\n        SELECT COALESCE(SUM(available_micro), 0) as cached_available\n        FROM credit_balances\n        WHERE account_id IN (${placeholders})\n      `).get(...accountIds) as { cached_available: number };\n```",
      "fixed_code": "```typescript\n      let lotSummary: {\n        total_lots: number;\n        total_created_micro: number;\n        total_consumed_micro: number;\n        total_available_micro: number;\n        total_reserved_micro: number;\n      } = {\n        total_lots: 0,\n        total_created_micro: 0,\n        total_consumed_micro: 0,\n        total_available_micro: 0,\n        total_reserved_micro: 0,\n      };\n\n      if (tableExists(db, 'credit_lots')) {\n        lotSummary = db.prepare(`\n          SELECT\n            COUNT(*) as total_lots,\n            COALESCE(SUM(original_micro), 0) as total_created_micro,\n            COALESCE(SUM(consumed_micro), 0) as total_consumed_micro,\n            COALESCE(SUM(available_micro), 0) as total_available_micro,\n            COALESCE(SUM(reserved_micro), 0) as total_reserved_micro\n          FROM credit_lots\n          WHERE account_id IN (${placeholders})\n        `).get(...accountIds) as {\n          total_lots: number;\n          total_created_micro: number;\n          total_consumed_micro: number;\n          total_available_micro: number;\n          total_reserved_micro: number;\n        };\n      }\n\n      let cachedBalance: { cached_available: number } = { cached_available: 0 };\n      if (tableExists(db, 'credit_balances')) {\n        cachedBalance = db.prepare(`\n          SELECT COALESCE(SUM(available_micro), 0) as cached_available\n          FROM credit_balances\n          WHERE account_id IN (${placeholders})\n        `).get(...accountIds) as { cached_available: number };\n      }\n```",
      "explanation": "This prevents crashes when migrations are missing by defaulting to zeroed summaries when tables don’t exist."
    },
    {
      "severity": "major",
      "file": "api/routes/admin-agent.ts",
      "line": 250,
      "description": "No helper exists to safely detect missing tables/columns, required by defensive coding for migrations.",
      "current_code": "```typescript\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction pseudonymizeWallet(wallet?: string | null): string | null {\n  if (!wallet) return null;\n  return wallet.length > 10\n    ? `${wallet.slice(0, 6)}...${wallet.slice(-4)}`\n    : wallet;\n}\n```",
      "fixed_code": "```typescript\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction pseudonymizeWallet(wallet?: string | null): string | null {\n  if (!wallet) return null;\n  return wallet.length > 10\n    ? `${wallet.slice(0, 6)}...${wallet.slice(-4)}`\n    : wallet;\n}\n\nfunction tableExists(db: ReturnType<typeof getDatabase>, tableName: string): boolean {\n  const row = db.prepare(\n    \"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\",\n  ).get(tableName) as { name?: string } | undefined;\n  return !!row?.name;\n}\n\nfunction tableHasColumn(\n  db: ReturnType<typeof getDatabase>,\n  tableName: string,\n  columnName: string,\n): boolean {\n  if (!tableExists(db, tableName)) return false;\n  // PRAGMA table_info does not support parameter binding; tableName is a fixed internal constant here\n  const cols = db.prepare(`PRAGMA table_info(${tableName})`).all() as Array<{ name: string }>;\n  return cols.some(c => c.name === columnName);\n}\n```",
      "explanation": "Adds safe schema checks used to avoid failures when migrations haven’t run and to enforce scoped queries."
    },
    {
      "severity": "major",
      "file": "api/routes/admin-agent.ts",
      "line": 468,
      "description": "Invariant violations query runs even if credit_lots table is missing, causing a crash.",
      "current_code": "```typescript\n      try {\n        const violations = db.prepare(`\n          SELECT\n            id,\n            original_micro,\n            (available_micro + reserved_micro + consumed_micro) as sum_micro,\n            original_micro - (available_micro + reserved_micro + consumed_micro) as delta_micro\n          FROM credit_lots\n          WHERE account_id IN (${placeholders})\n            AND original_micro != (available_micro + reserved_micro + consumed_micro)\n          LIMIT 20\n        `).all(...accountIds) as Array<{\n          id: string;\n          original_micro: number;\n          sum_micro: number;\n          delta_micro: number;\n        }>;\n\n        invariantViolations = violations.map(v => ({\n          lotId: v.id,\n          originalMicro: v.original_micro,\n          sumMicro: v.sum_micro,\n          deltaMicro: v.delta_micro,\n        }));\n      } catch {\n        // Query may fail if columns changed\n      }\n```",
      "fixed_code": "```typescript\n      try {\n        if (tableExists(db, 'credit_lots')) {\n          const violations = db.prepare(`\n            SELECT\n              id,\n              original_micro,\n              (available_micro + reserved_micro + consumed_micro) as sum_micro,\n              original_micro - (available_micro + reserved_micro + consumed_micro) as delta_micro\n            FROM credit_lots\n            WHERE account_id IN (${placeholders})\n              AND original_micro != (available_micro + reserved_micro + consumed_micro)\n            LIMIT 20\n          `).all(...accountIds) as Array<{\n            id: string;\n            original_micro: number;\n            sum_micro: number;\n            delta_micro: number;\n          }>;\n\n          invariantViolations = violations.map(v => ({\n            lotId: v.id,\n            originalMicro: v.original_micro,\n            sumMicro: v.sum_micro,\n            deltaMicro: v.delta_micro,\n          }));\n        } else {\n          invariantViolations = [];\n        }\n      } catch {\n        // Query may fail if columns changed\n      }\n```",
      "explanation": "Avoids runtime errors when the table is missing and returns an empty list instead."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1
}
