{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Two logic bugs allow claimed reservations without an estimated_cost field to skip reserved decrement, causing accounting drift.",
  "issues": [
    {
      "severity": "major",
      "file": "budget_finalize.lua",
      "line": 52,
      "description": "Claimed reservations with missing/empty estimated_cost are treated as late finalize, so reserved is not decremented even though this script successfully claimed (DEL=1). This can permanently leak reserved budget.",
      "current_code": "```lua\nlocal estimatedCostRaw = redis.call('HGET', KEYS[3], 'estimated_cost')\nlocal claimed = redis.call('DEL', KEYS[3])\n\nif claimed == 1 and estimatedCostRaw then\n  -- Normal finalize: we claimed the reservation → DECRBY reserved, INCRBY committed\n  local estimatedCost = tonumber(estimatedCostRaw) or 0\n  if estimatedCost < 0 then estimatedCost = 0 end\n  estimatedCost = math.floor(estimatedCost)\n\n  -- Decrement reserved by estimated cost (only we can do this — we won the claim)\n  redis.call('DECRBY', KEYS[2], estimatedCost)\n  -- Safety clamp: reserved should never go negative with claim-via-DEL,\n  -- but clamp as defense-in-depth and log if it happens\n  local reserved = tonumber(redis.call('GET', KEYS[2]) or '0') or 0\n  if reserved < 0 then\n    redis.log(redis.LOG_WARNING, 'ACCOUNTING_DRIFT finalize community=' .. ARGV[2] .. ' drift_cents=' .. tostring(math.abs(reserved)) .. ' operation=finalize')\n    redis.call('SET', KEYS[2], '0')\n    redis.call('PEXPIRE', KEYS[2], monthlyTtlMs)\n  end\n\n  -- Increment committed by actual cost\n  redis.call('INCRBY', KEYS[1], actualCost)\n  redis.call('PEXPIRE', KEYS[1], monthlyTtlMs)\n  redis.call('PEXPIRE', KEYS[2], monthlyTtlMs)\n\n  -- Clean up expiry member\n  redis.call('ZREM', KEYS[4], expiryMember)\n\n  -- Set finalized marker (24h TTL)\n  redis.call('SET', KEYS[5], actualCost, 'PX', 24 * 60 * 60 * 1000)\n\n  return {'FINALIZED', tostring(actualCost)}\nelse\n  -- Late finalize: reservation already claimed by reaper (or never existed).\n  -- Reaper already decremented reserved, so we only add actual cost to committed.\n  redis.call('INCRBY', KEYS[1], actualCost)\n  redis.call('PEXPIRE', KEYS[1], monthlyTtlMs)\n\n  -- Clean up expiry member (might still be there if reaper hasn't run yet)\n  redis.call('ZREM', KEYS[4], expiryMember)\n\n  -- Set finalized marker (24h TTL)\n  redis.call('SET', KEYS[5], actualCost, 'PX', 24 * 60 * 60 * 1000)\n\n  return {'LATE_FINALIZE', tostring(actualCost)}\nend\n```",
      "fixed_code": "```lua\nlocal estimatedCostRaw = redis.call('HGET', KEYS[3], 'estimated_cost')\nlocal claimed = redis.call('DEL', KEYS[3])\n\nif claimed == 1 then\n  -- Normal finalize: we claimed the reservation → DECRBY reserved, INCRBY committed\n  local estimatedCost = tonumber(estimatedCostRaw) or 0\n  if estimatedCost < 0 then estimatedCost = 0 end\n  estimatedCost = math.floor(estimatedCost)\n\n  -- Decrement reserved by estimated cost (only we can do this — we won the claim)\n  redis.call('DECRBY', KEYS[2], estimatedCost)\n  -- Safety clamp: reserved should never go negative with claim-via-DEL,\n  -- but clamp as defense-in-depth and log if it happens\n  local reserved = tonumber(redis.call('GET', KEYS[2]) or '0') or 0\n  if reserved < 0 then\n    redis.log(redis.LOG_WARNING, 'ACCOUNTING_DRIFT finalize community=' .. ARGV[2] .. ' drift_cents=' .. tostring(math.abs(reserved)) .. ' operation=finalize')\n    redis.call('SET', KEYS[2], '0')\n    redis.call('PEXPIRE', KEYS[2], monthlyTtlMs)\n  end\n\n  -- Increment committed by actual cost\n  redis.call('INCRBY', KEYS[1], actualCost)\n  redis.call('PEXPIRE', KEYS[1], monthlyTtlMs)\n  redis.call('PEXPIRE', KEYS[2], monthlyTtlMs)\n\n  -- Clean up expiry member\n  redis.call('ZREM', KEYS[4], expiryMember)\n\n  -- Set finalized marker (24h TTL)\n  redis.call('SET', KEYS[5], actualCost, 'PX', 24 * 60 * 60 * 1000)\n\n  return {'FINALIZED', tostring(actualCost)}\nelse\n  -- Late finalize: reservation already claimed by reaper (or never existed).\n  -- Reaper already decremented reserved, so we only add actual cost to committed.\n  redis.call('INCRBY', KEYS[1], actualCost)\n  redis.call('PEXPIRE', KEYS[1], monthlyTtlMs)\n\n  -- Clean up expiry member (might still be there if reaper hasn't run yet)\n  redis.call('ZREM', KEYS[4], expiryMember)\n\n  -- Set finalized marker (24h TTL)\n  redis.call('SET', KEYS[5], actualCost, 'PX', 24 * 60 * 60 * 1000)\n\n  return {'LATE_FINALIZE', tostring(actualCost)}\nend\n```",
      "explanation": "DEL is the claim signal. If DEL returns 1, this script owns the reservation and must perform the reserved decrement even if estimated_cost is missing or malformed. Defaulting to 0 preserves safety while preventing leaked reserved balance."
    },
    {
      "severity": "major",
      "file": "budget_reaper.lua",
      "line": 40,
      "description": "Claimed reservations with missing/empty estimated_cost are ignored, so reserved is not decremented even though the reaper successfully claimed (DEL=1). This leaks reserved budget and can cause drift.",
      "current_code": "```lua\n  local estimatedCostRaw = redis.call('HGET', reservationKey, 'estimated_cost')\n  local claimed = redis.call('DEL', reservationKey)\n\n  if claimed == 1 and estimatedCostRaw then\n    -- We won the claim: include in totalReclaimed for DECRBY\n    local estimatedCost = tonumber(estimatedCostRaw) or 0\n    if estimatedCost < 0 then estimatedCost = 0 end\n    estimatedCost = math.floor(estimatedCost)\n    totalReclaimed = totalReclaimed + estimatedCost\n  end\n```",
      "fixed_code": "```lua\n  local estimatedCostRaw = redis.call('HGET', reservationKey, 'estimated_cost')\n  local claimed = redis.call('DEL', reservationKey)\n\n  if claimed == 1 then\n    -- We won the claim: include in totalReclaimed for DECRBY\n    local estimatedCost = tonumber(estimatedCostRaw) or 0\n    if estimatedCost < 0 then estimatedCost = 0 end\n    estimatedCost = math.floor(estimatedCost)\n    totalReclaimed = totalReclaimed + estimatedCost\n  end\n```",
      "explanation": "DEL is the claim signal. If the reaper successfully deletes the reservation, it must account for it even if estimated_cost is missing. Defaulting to 0 prevents drift while keeping the claim-via-DEL correctness."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1
}
