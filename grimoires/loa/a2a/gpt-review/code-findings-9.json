{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Found security and correctness issues in upgrade authorization, S2S auth handling, and SSE stream cleanup.",
  "issues": [
    {
      "severity": "critical",
      "file": "api/routes/developer.ts",
      "line": 132,
      "description": "S2S authorization secret may be empty, causing unauthenticated gateway calls.",
      "current_code": "```typescript\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${process.env.DEVELOPER_API_S2S_SECRET || process.env.BILLING_INTERNAL_JWT_SECRET || ''}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n  }),\n  signal: AbortSignal.timeout(60_000),\n});\n```",
      "fixed_code": "```typescript\nconst s2sSecret = process.env.DEVELOPER_API_S2S_SECRET || process.env.BILLING_INTERNAL_JWT_SECRET;\nif (!s2sSecret) {\n  res.status(503).json({\n    error: 'Inference service not configured',\n    message: 'Missing service-to-service credentials for gateway authentication.',\n  });\n  return;\n}\n\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${s2sSecret}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n  }),\n  signal: AbortSignal.timeout(60_000),\n});\n```",
      "explanation": "Ensures gateway calls are authenticated and prevents accidental unauthenticated access when secrets are missing."
    },
    {
      "severity": "critical",
      "file": "api/routes/developer.ts",
      "line": 208,
      "description": "S2S authorization secret may be empty in streaming proxy, leading to unauthenticated gateway calls.",
      "current_code": "```typescript\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${process.env.DEVELOPER_API_S2S_SECRET || process.env.BILLING_INTERNAL_JWT_SECRET || ''}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n    stream: true,\n  }),\n  signal: AbortSignal.timeout(120_000),\n});\n```",
      "fixed_code": "```typescript\nconst s2sSecret = process.env.DEVELOPER_API_S2S_SECRET || process.env.BILLING_INTERNAL_JWT_SECRET;\nif (!s2sSecret) {\n  res.status(503).json({\n    error: 'Inference service not configured',\n    message: 'Missing service-to-service credentials for gateway authentication.',\n  });\n  return;\n}\n\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${s2sSecret}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n    stream: true,\n  }),\n  signal: AbortSignal.timeout(120_000),\n});\n```",
      "explanation": "Prevents streaming proxy from calling the gateway without valid S2S authentication."
    },
    {
      "severity": "major",
      "file": "api/routes/developer.ts",
      "line": 318,
      "description": "Upgrade endpoint does not verify that the provided sandboxKeyId matches the authenticated sandbox key, allowing misleading or incorrect upgrades.",
      "current_code": "```typescript\n// Only sandbox keys can be upgraded\nif (!req.isSandboxKey) {\n  res.status(400).json({ error: 'Only sandbox (test) keys can be upgraded' });\n  return;\n}\n\n// Create a new live key with same community, higher limits\nconst result = await createApiKey({\n  userId: keyRecord.user_id,\n  communityId: keyRecord.community_id,\n  name: parsed.data.name || `${keyRecord.name} (upgraded)`,\n  mode: 'live',\n  rateLimitRpm: parsed.data.rateLimitRpm ?? 60,\n  rateLimitTpd: parsed.data.rateLimitTpd ?? 100_000,\n});\n```",
      "fixed_code": "```typescript\n// Only sandbox keys can be upgraded\nif (!req.isSandboxKey) {\n  res.status(400).json({ error: 'Only sandbox (test) keys can be upgraded' });\n  return;\n}\n\n// Ensure the sandboxKeyId matches the authenticated key\nif (parsed.data.sandboxKeyId !== keyRecord.id) {\n  res.status(403).json({ error: 'Sandbox key mismatch' });\n  return;\n}\n\n// Create a new live key with same community, higher limits\nconst result = await createApiKey({\n  userId: keyRecord.user_id,\n  communityId: keyRecord.community_id,\n  name: parsed.data.name || `${keyRecord.name} (upgraded)`,\n  mode: 'live',\n  rateLimitRpm: parsed.data.rateLimitRpm ?? 60,\n  rateLimitTpd: parsed.data.rateLimitTpd ?? 100_000,\n});\n```",
      "explanation": "Guarantees that upgrades apply only to the authenticated sandbox key and prevents misleading or unauthorized upgrades."
    },
    {
      "severity": "major",
      "file": "api/routes/developer.ts",
      "line": 198,
      "description": "Streaming proxy does not abort the upstream fetch or reader on client disconnect, causing resource leaks and unnecessary gateway usage.",
      "current_code": "```typescript\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${process.env.DEVELOPER_API_S2S_SECRET || process.env.BILLING_INTERNAL_JWT_SECRET || ''}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n    stream: true,\n  }),\n  signal: AbortSignal.timeout(120_000),\n});\n\n// Set up SSE response\nres.setHeader('Content-Type', 'text/event-stream');\nres.setHeader('Cache-Control', 'no-cache');\nres.setHeader('Connection', 'keep-alive');\nres.flushHeaders();\n\n// Heartbeat\nconst heartbeat = setInterval(() => {\n  res.write(': keepalive\\n\\n');\n}, 15_000);\n\nconst onClose = () => clearInterval(heartbeat);\nreq.on('close', onClose);\nres.on('close', onClose);\n\ntry {\n  const reader = gatewayResponse.body.getReader();\n  const decoder = new TextDecoder();\n  let totalTokens = 0;\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n\n    const chunk = decoder.decode(value, { stream: true });\n    res.write(chunk);\n\n    // Try to parse usage from SSE chunks for TPD tracking\n    const usageMatch = chunk.match(/\"total_tokens\":\\s*(\\d+)/);\n    if (usageMatch) {\n      totalTokens = parseInt(usageMatch[1], 10);\n    }\n  }\n\n  // Record token usage\n  if (totalTokens > 0) {\n    recordTokenUsage(keyRecord.id, totalTokens);\n  }\n} finally {\n  clearInterval(heartbeat);\n}\n\nres.end();\n```",
      "fixed_code": "```typescript\nconst controller = new AbortController();\nconst streamTimeout = setTimeout(() => controller.abort(), 120_000);\nlet reader: ReadableStreamDefaultReader<Uint8Array> | null = null;\n\nconst gatewayResponse = await fetch(`${loaFinnUrl}/v1/chat/completions`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Developer-Key-Id': keyRecord.id,\n    'X-Developer-Community-Id': keyRecord.community_id,\n    'X-Developer-Pool': requestedPool,\n    'X-Developer-Access-Level': isSandbox ? 'free' : 'pro',\n    'X-Developer-Is-Sandbox': String(!!isSandbox),\n    'Authorization': `Bearer ${s2sSecret}`,\n  },\n  body: JSON.stringify({\n    model: parsed.data.model,\n    pool: requestedPool,\n    messages: parsed.data.messages,\n    max_tokens: parsed.data.max_tokens,\n    temperature: parsed.data.temperature,\n    stream: true,\n  }),\n  signal: controller.signal,\n});\n\n// Set up SSE response\nres.setHeader('Content-Type', 'text/event-stream');\nres.setHeader('Cache-Control', 'no-cache');\nres.setHeader('Connection', 'keep-alive');\nres.flushHeaders();\n\n// Heartbeat\nconst heartbeat = setInterval(() => {\n  res.write(': keepalive\\n\\n');\n}, 15_000);\n\nconst onClose = () => {\n  clearInterval(heartbeat);\n  clearTimeout(streamTimeout);\n  controller.abort();\n  if (reader) {\n    reader.cancel().catch(() => undefined);\n  }\n};\nreq.on('close', onClose);\nres.on('close', onClose);\n\ntry {\n  reader = gatewayResponse.body.getReader();\n  const decoder = new TextDecoder();\n  let totalTokens = 0;\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n\n    const chunk = decoder.decode(value, { stream: true });\n    res.write(chunk);\n\n    // Try to parse usage from SSE chunks for TPD tracking\n    const usageMatch = chunk.match(/\"total_tokens\":\\s*(\\d+)/);\n    if (usageMatch) {\n      totalTokens = parseInt(usageMatch[1], 10);\n    }\n  }\n\n  // Record token usage\n  if (totalTokens > 0) {\n    recordTokenUsage(keyRecord.id, totalTokens);\n  }\n} finally {\n  clearInterval(heartbeat);\n  clearTimeout(streamTimeout);\n}\n\nres.end();\n```",
      "explanation": "Aborts the upstream request and reader on client disconnect or timeout, preventing resource leaks and unnecessary gateway load."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1
}
