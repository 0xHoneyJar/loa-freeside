{
  "verdict": "CHANGES_REQUIRED",
  "summary": "The design is close, but several security/trust-boundary contradictions and state-machine/schema mismatches will cause auth outages, double-mint risk, and budget leakage in production.",
  "blocking_issues": [
    {
      "location": "1.9 Security Architecture + 5.2 S2S Contract + 1.7/1.8 Deployment (finn internal-only)",
      "issue": "S2S JWT verification depends on finn fetching JWKS from the public ALB domain, which contradicts “finn internal-only / SG enforcement” and can fail at runtime due to egress/DNS/TLS constraints; also creates an unnecessary trust path through the public edge.",
      "why_blocking": "If finn cannot reach `https://api.{domain}/.well-known/jwks.json` (no NAT, restrictive egress, DNS split-horizon, TLS inspection, ALB outage), all inference requests fail (401) even though freeside→finn network is healthy. It also weakens the stated trust boundary by making internal auth depend on an external/public endpoint.",
      "fix": "Host JWKS on an internal-only endpoint reachable from finn without public egress (e.g., freeside internal Cloud Map name behind a private NLB/ALB, or a dedicated internal JWKS service). Alternatively, embed JWKS in finn via Secrets Manager/SSM (pull on startup + periodic refresh) and rotate by publishing new public keys there. Keep the public JWKS only if you truly need third-party verifiers; don’t make finn depend on it."
    },
    {
      "location": "3.2 JWKS Key Store + 1.9 Key rotation design",
      "issue": "Storing `private_key_secret_arn` in a database table and driving signing-key selection from DB introduces a high-impact compromise path and operational coupling; also unclear how freeside selects the active signing key safely during rotation.",
      "why_blocking": "A DB read path becomes part of the signing trust root. Any SQL injection/DB leak now reveals the ARN of the private key and enables targeted secret exfiltration attempts; more importantly, if DB is degraded, freeside may be unable to sign S2S JWTs (hard outage). Rotation logic spanning DB + Secrets Manager + Lambda is brittle and easy to misconfigure, causing auth outages.",
      "fix": "Make Secrets Manager (or KMS) the source of truth for signing keys and rotation. Keep only public keys (or JWKS JSON) in DB if you must, but do not store private-key references there. Implement signer selection via a single secret containing `{activeKid, keys...}` or via KMS key aliases. Ensure freeside can sign even if DB is unavailable (cache active key in memory + refresh)."
    },
    {
      "location": "Payment Flow + 3.2 Payment State Machine Extension + 4.1/Phase 2 (NOWPayments)",
      "issue": "The payment state machine is underspecified/incorrect relative to the requirement “all IPN statuses + reconciliation job”: the schema uses free-text `ipn_status TEXT` and the flow mints credits on a single transition to `finished` without defining allowed transitions, terminal states, or handling partial/failed/refunded/chargeback equivalents.",
      "why_blocking": "NOWPayments sends multiple statuses and can deliver out-of-order/replayed IPNs. Without an explicit transition guard and terminal-state rules, you can double-mint (e.g., `finished` then later `refunded`/`failed`), mint on a spoofed/incorrect status, or get stuck payments that never reconcile correctly. This is a direct revenue-loss / accounting-integrity failure.",
      "fix": "Define an explicit enum-like status set matching NOWPayments (e.g., `waiting`, `confirming`, `confirmed`, `sending`, `partially_paid`, `finished`, `failed`, `refunded`, `expired`, `chargeback` if applicable) and implement a transition table with monotonic ordering + terminal states. Persist `last_ipn_status`, `last_ipn_at`, and a numeric `status_rank` (or `updated_at` guard) to ignore stale/out-of-order updates. Mint credits only on the first transition into the terminal “paid” state, enforced by a DB transaction + unique constraint (e.g., `credit_lots.payment_id UNIQUE`). Reconciliation job must also be idempotent and use the same transition rules."
    },
    {
      "location": "Payment webhook security (5.4 NOWPayments Webhook) + ALB routing",
      "issue": "Webhook verification is described as HMAC-SHA512 only, but the design does not specify canonical payload handling, raw-body capture, or replay protection; Express JSON parsing will break signature verification unless raw body is preserved.",
      "why_blocking": "If you verify HMAC over a re-serialized JSON body (typical with Express), signatures will fail intermittently or always, causing missed payments. Conversely, if verification is implemented incorrectly, an attacker can forge IPNs and mint credits.",
      "fix": "Explicitly require raw request body capture for `/api/crypto/webhook` (Express `verify` hook) and compute HMAC over the exact raw bytes per NOWPayments spec. Add replay protection: store `ipn_id`/event id if provided, or hash of payload + timestamp window; enforce idempotency at DB level. Document the exact header name (`x-nowpayments-sig`) and algorithm inputs."
    },
    {
      "location": "Budget lifecycle (1.5 Inference flow + 3.2 Budget Reservations + 3.6 Caching + Phase 3)",
      "issue": "Budget reserve→stream→finalize is described, but the SDD does not define how streaming finalization is made atomic and safe under disconnects/timeouts; the schema lacks a hard link to the spend ledger/credit lots and does not enforce single-finalization.",
      "why_blocking": "Streaming introduces common failure modes: client disconnect after reserve, finn completes but freeside never finalizes, retries cause double-finalize, or finalize happens with mismatched reservation. Without DB-enforced idempotency and a clear ledger linkage, you will leak or double-charge credits—violating the “formal economic verification / conservation guard” requirement.",
      "fix": "Enforce idempotency and single-finalization in DB: add a unique constraint on `(budget_reservation_id)` already exists, but also enforce `finalized_at IS NULL` update condition and store a `finalization_id`/`request_id`. Link reservations to the actual spend ledger entry (e.g., `spend_events` table or `credit_lot_debits`) with a unique FK so finalize can’t run twice. Define orphan cleanup semantics precisely: when to release vs when to finalize from finn-reported usage (e.g., if finn returns `done` event but freeside missed it, reconcile via persisted usage callback or finn-side usage record)."
    },
    {
      "location": "Discord thread gating (1.9 Authorization + 4.1 Discord Surfaces + Phase 4)",
      "issue": "“Ownership re-verified per-message” is not implementable at scale/latency if it requires on-chain calls; caching 60s is stated but token transfer handling requires stronger guarantees and a clear source of truth for ownership at message time.",
      "why_blocking": "If you truly re-verify on-chain per message, you will hit rate limits and latency spikes; if you rely on a 60s cache, a transferred NFT can keep access for up to 60s (or longer under failures), violating “bot-enforced gating” and creating security/support incidents.",
      "fix": "Define the ownership verification mechanism: use an indexed ownership service (existing conviction/wallet verification subsystem) with event-driven updates (transfer events) and short TTL cache only as a performance layer. On transfer detection, immediately invalidate thread access (Redis delete + DB status update). For per-message checks, use cached ownership with a strict max staleness and a fallback to deny on verifier outage (fail-closed for gated actions)."
    },
    {
      "location": "API key hashing (1.9 Security Architecture + 3.2 API Keys + 5.6)",
      "issue": "API keys are specified as “hashed at rest with bcrypt” but the auth path is “lookup by prefix + Redis cache”; bcrypt is not suitable for high-QPS API key verification without careful design, and the document doesn’t specify constant-time compare, peppering, or how prefix lookup avoids oracle/leakage.",
      "why_blocking": "At launch of Product B, API key auth is on the hot path. A naive bcrypt verify per request will become a CPU bottleneck and can be DoS’d. A naive prefix lookup + cache can leak key validity via timing and may allow enumeration if prefixes are short or not random enough.",
      "fix": "Use a two-part key: `prefix` (public identifier) + `secret` (high entropy). Store `prefix`, `hash(secret)` using a fast keyed hash for lookup (e.g., HMAC-SHA256 with server-side pepper in Secrets Manager) or use Argon2id with strict rate limiting and mandatory Redis caching. Ensure prefixes are sufficiently long/random (e.g., 10+ chars base32) and enforce constant-time comparisons. Document cache negative lookups and lockout/backoff on repeated failures."
    },
    {
      "location": "ECS/PgBouncer design (1.4 PgBouncer + 3.1 Data access patterns)",
      "issue": "PgBouncer “read-only pool” for loa-finn is stated, but Postgres cannot enforce read-only at the pool level unless you use a read-only DB user and/or transaction-level `default_transaction_read_only`; this is not specified.",
      "why_blocking": "If finn accidentally (or via compromise) writes to the primary DB, it can corrupt billing/budget invariants. Relying on “read-only” as a config comment is not a control.",
      "fix": "Create a dedicated DB role for finn with SELECT-only permissions on required tables/views, and set `default_transaction_read_only=on` for that role. In PgBouncer, map finn to that user. Prefer exposing only the minimal read models finn needs (or none, if personality routing is internal to finn)."
    }
  ],
  "question": "",
  "iteration": 1
}
