{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Mostly surgical and implementable, but two schema/migration assumptions and one reconciliation/typing boundary can break production merges or silently invalidate conservation checks.",
  "blocking_issues": [
    {
      "location": "2.3 Type System — EntryType Extension (FR-3) / 3.1 Schema Amendments",
      "issue": "Plan says to amend the migration that added 'transfer_out' to the credit_ledger entry_type CHECK, but the only explicitly referenced migration is 057_tba_deposits.ts; it is not guaranteed that 057 is where credit_ledger is created or where its CHECK constraint lives.",
      "why_blocking": "If the CHECK constraint is defined in an earlier migration (common), changing 057 will not update the actual constraint in environments where credit_ledger already exists. Result: runtime inserts of entry_type='transfer_in' will fail with CHECK constraint violations, breaking peer transfers and reconciliation end-to-end.",
      "fix": "Locate the migration that creates/defines credit_ledger (or the migration that introduced the entry_type CHECK). If 057 truly creates credit_ledger (unlikely given its name), document that explicitly. Otherwise: add a new migration that rebuilds credit_ledger with an updated CHECK (SQLite cannot ALTER CHECK in-place), or implement a safe table-rebuild pattern (create new table with new CHECK, copy data, drop old, rename) gated by foreign keys/index recreation. Update SDD to reference the correct migration file and exact constraint SQL."
    },
    {
      "location": "2.2 Migration 057 — TBA Deposit CHECK Constraint (FR-2)",
      "issue": "The compound CHECK uses status='bridged' as the only state requiring amount_micro > 0, but the document simultaneously notes PRD’s 6-state lifecycle vs the migration’s 4 states; the chosen semantics may be wrong for the actual meaning of 'bridged' in code (could represent 'bridge initiated' vs 'bridge completed').",
      "why_blocking": "If 'bridged' is used as an intermediate state (or if code sets status='bridged' before amount_micro is known/normalized), the new CHECK will start rejecting legitimate state transitions/inserts, causing the bridge pipeline to fail at the database layer. This is especially risky because the SDD asserts “no table rebuild required” and intends to amend 057 directly—so the constraint becomes the single point of failure for deposit ingestion.",
      "fix": "Confirm the exact state machine used by TbaDepositBridge code (what transitions exist and when amount_micro is set). If 'bridged' means “completed and credited”, the CHECK is fine; if it means “submitted/processing”, introduce a distinct terminal state (e.g., 'completed') or adjust the CHECK to enforce >0 only on the true terminal credited state. Update acceptance tests to cover the real transition sequence (insert detected(0) → confirmed(0 or >0?) → bridged(>0) with the same row)."
    },
    {
      "location": "2.1 ReconciliationService — Check 5 Table Reference (FR-1)",
      "issue": "Changing “silent skip” to “propagate error as failure” is correct, but the SDD doesn’t specify how reconcile() reports failures vs throws, and it assumes the only failure mode is a wrong table name. If reconcile() currently treats thrown errors as aborting the entire reconciliation run, this change can take reconciliation offline rather than producing a structured failed check result.",
      "why_blocking": "Reconciliation is a financial integrity gate. If it starts throwing (instead of returning a structured report) in normal conditions (e.g., transient DB errors, schema mismatch during rollout), downstream systems may stop processing or fail deployments. That’s a project-level failure mode because it blocks merges/releases and can mask which invariant failed.",
      "fix": "Define the contract: either (a) reconcile() always returns a report with per-check {passed|failed} and includes error details without throwing, or (b) reconcile() throws only on programmer errors and callers handle it. Implement accordingly: wrap the query in a try/catch that records {status:'failed', error:'...'} rather than {skipped:true}, and only throw if you intentionally want to abort. Add a test asserting reconcile() returns a report with Check 5 status='failed' and an error message when the SQL is invalid."
    },
    {
      "location": "2.4 SqliteTimestamp Branded Type (FR-4) / 5. File Manifest (“Service files with *_at insert/update params”)",
      "issue": "Branding SqliteTimestamp only at TypeScript level does not prevent raw strings coming from SQLite rows (which are typed as string) from being used in comparisons/updates; without explicit casting/validation at the DB boundary, the brand can be bypassed and the original ordering bug (ISO 'T' vs space) can reappear via mixed sources.",
      "why_blocking": "The stated goal is to prevent timestamp comparison semantics bugs. If row reads return plain string and are later written back or compared against branded timestamps, developers will either cast unsafely (as SqliteTimestamp) or widen types back to string, defeating the safety and allowing the same class of bugs to persist unnoticed.",
      "fix": "Add explicit boundary functions: e.g., parseSqliteTimestamp(s: string): SqliteTimestamp that validates isSqliteFormat(s) and brands it; and ensure all DB row mappers use it for *_at fields. For writes, require SqliteTimestamp. Add one runtime test that rejects ISO format at the mapper boundary (not just compile-time). Keep scope limited to cycle-031 touched services as intended."
    }
  ],
  "question": null,
  "iteration": 1
}
