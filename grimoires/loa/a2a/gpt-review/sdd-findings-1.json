{
  "verdict": "CHANGES_REQUIRED",
  "summary": "The design is close, but several Terraform/HCL constructs and DNSSEC/DNS validation details are incorrect or incomplete in ways that can break applies or cause failed DNSSEC/email/DNS equivalence during cutover.",
  "issues": [
    {
      "severity": "critical",
      "file": "infrastructure/terraform/dns/honeyjar-xyz-backend.tf",
      "line": 2,
      "description": "Invalid use of `data.aws_lb` with `tags` filter; the `aws_lb` data source does not support a `tags` argument in AWS provider ~> 5.x, so DNS root will fail to plan/apply when `enable_production_api=true`.",
      "current_code": "data \"aws_lb\" \"compute_alb\" {\n  count = var.enable_production_api ? 1 : 0\n\n  tags = {\n    Name = \"${local.name_prefix}-alb\"\n  }\n}\n",
      "fixed_code": "data \"aws_lbs\" \"compute_alb\" {\n  count = var.enable_production_api ? 1 : 0\n\n  tags = {\n    Name = \"${local.name_prefix}-alb\"\n  }\n}\n\n# Select the single expected ALB\nlocals {\n  compute_alb_arn = var.enable_production_api ? one(data.aws_lbs.compute_alb[0].arns) : null\n}\n\ndata \"aws_lb\" \"compute_alb\" {\n  count = var.enable_production_api ? 1 : 0\n  arn   = local.compute_alb_arn\n}\n",
      "explanation": "`aws_lbs` supports tag filtering and returns a list of ARNs; using `one(...)` enforces exactly one match, and then `aws_lb` can read `dns_name`/`zone_id` from the selected ARN."
    },
    {
      "severity": "critical",
      "file": "infrastructure/terraform/dns/honeyjar-xyz-backend.tf",
      "line": 2,
      "description": "The earlier SDD snippet uses `lifecycle.postcondition` inside a data source and references `self` as a collection (`length(self)`), which is invalid; `self` is an object, and postconditions must check attributes, not the count wrapper.",
      "current_code": "data \"aws_lb\" \"compute_alb\" {\n  count = var.enable_production_api ? 1 : 0\n\n  tags = {\n    Name = \"arrakis-${var.environment}-alb\"\n  }\n\n  lifecycle {\n    postcondition {\n      condition     = length(self) == 1\n      error_message = \"Expected exactly one ALB matching arrakis-${var.environment}-alb\"\n    }\n  }\n}\n",
      "fixed_code": "data \"aws_lbs\" \"compute_alb\" {\n  count = var.enable_production_api ? 1 : 0\n\n  tags = {\n    Name = \"arrakis-${var.environment}-alb\"\n  }\n\n  lifecycle {\n    postcondition {\n      condition     = length(self.arns) == 1\n      error_message = \"Expected exactly one ALB matching arrakis-${var.environment}-alb\"\n    }\n  }\n}\n",
      "explanation": "Postconditions can validate returned attributes; `aws_lbs` exposes `arns`, so `length(self.arns)==1` correctly enforces determinism."
    },
    {
      "severity": "critical",
      "file": "infrastructure/terraform/dns/main.tf",
      "line": 6,
      "description": "Provider version constraint is malformed; `aws = \"~> 5.0\"` must be nested under `required_providers.aws.source/version`, otherwise Terraform init will fail.",
      "current_code": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = \"~> 5.0\"\n  }\n\n  backend \"s3\" {\n    bucket         = \"arrakis-tfstate-891376933289\"\n    region         = \"us-east-1\"\n    encrypt        = true\n    dynamodb_table = \"arrakis-terraform-locks\"\n  }\n}\n",
      "fixed_code": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n\n  backend \"s3\" {\n    bucket         = \"arrakis-tfstate-891376933289\"\n    region         = \"us-east-1\"\n    encrypt        = true\n    dynamodb_table = \"arrakis-terraform-locks\"\n  }\n}\n",
      "explanation": "Terraform requires `required_providers` entries to be objects with `source` and `version` (or at least `version`), not a bare string."
    },
    {
      "severity": "critical",
      "file": "infrastructure/terraform/dns/main.tf",
      "line": 13,
      "description": "Backend key cannot be set via `*.tfvars` as stated; `backend \"s3\"` does not read `var.*` or tfvars. Without `-backend-config=key=...` (or a backend config file), both environments will collide on the same state key or fail expectations.",
      "current_code": "backend \"s3\" {\n  bucket         = \"arrakis-tfstate-891376933289\"\n  region         = \"us-east-1\"\n  encrypt        = true\n  dynamodb_table = \"arrakis-terraform-locks\"\n  # key set in environments/*.tfvars: \"dns/staging.tfstate\" or \"dns/production.tfstate\"\n}\n",
      "fixed_code": "backend \"s3\" {\n  bucket         = \"arrakis-tfstate-891376933289\"\n  region         = \"us-east-1\"\n  encrypt        = true\n  dynamodb_table = \"arrakis-terraform-locks\"\n  # key is set via -backend-config, e.g.:\n  # terraform init -backend-config=environments/staging/backend.tfvars\n}\n",
      "explanation": "Terraform backend configuration is loaded only at init time via `-backend-config` (or hardcoded in the backend block). Using tfvars for backend keys is not supported."
    },
    {
      "severity": "critical",
      "file": "infrastructure/terraform/s3-finn.tf",
      "line": 1,
      "description": "S3 Object Lock cannot be enabled after bucket creation; `aws_s3_bucket_object_lock_configuration` requires the bucket to have been created with Object Lock enabled. The bucket resource is missing `object_lock_enabled = true`, so apply/import will fail or drift irreconcilably.",
      "current_code": "resource \"aws_s3_bucket\" \"finn_audit_anchors\" {\n  bucket = \"${local.name_prefix}-finn-audit-anchors\"\n\n  lifecycle {\n    prevent_destroy = true\n  }\n\n  tags = merge(local.common_tags, {\n    Service = \"finn\"\n    Purpose = \"audit-anchors\"\n  })\n}\n",
      "fixed_code": "resource \"aws_s3_bucket\" \"finn_audit_anchors\" {\n  bucket              = \"${local.name_prefix}-finn-audit-anchors\"\n  object_lock_enabled = true\n\n  lifecycle {\n    prevent_destroy = true\n  }\n\n  tags = merge(local.common_tags, {\n    Service = \"finn\"\n    Purpose = \"audit-anchors\"\n  })\n}\n",
      "explanation": "Object Lock is a bucket-level immutable setting that must be enabled at creation; adding `object_lock_enabled = true` aligns Terraform with the required precondition for the lock configuration resource."
    },
    {
      "severity": "major",
      "file": "infrastructure/terraform/elasticache-finn.tf",
      "line": 1,
      "description": "ElastiCache Redis with `transit_encryption_enabled = true` and `auth_token` requires a parameter group family compatible with the engine version; `family = \"redis7\"` may not match `engine_version = \"7.1\"` depending on AWS offering (often `redis7` is fine, but mismatches cause create/update failure). Pin family to the exact supported family for the chosen engine version in the target region.",
      "current_code": "resource \"aws_elasticache_parameter_group\" \"finn_redis\" {\n  family = \"redis7\"\n  name   = \"${local.name_prefix}-finn-redis-params\"\n  ...\n}\n",
      "fixed_code": "resource \"aws_elasticache_parameter_group\" \"finn_redis\" {\n  # Ensure this matches the engine major version supported in-region for 7.1\n  family = \"redis7\"\n  name   = \"${local.name_prefix}-finn-redis-params\"\n\n  parameter {\n    name  = \"maxmemory-policy\"\n    value = \"noeviction\"\n  }\n\n  parameter {\n    name  = \"appendonly\"\n    value = \"yes\"\n  }\n\n  parameter {\n    name  = \"appendfsync\"\n    value = \"everysec\"\n  }\n}\n",
      "explanation": "This is a verification requirement: if AWS requires a different family string for 7.1 in the chosen region, the replication group will fail to create/update. Confirm via `aws elasticache describe-cache-parameter-groups` / docs and adjust if needed."
    }
  ],
  "blocking_issues": [
    {
      "location": "§7 DNS Module Design — backend configuration",
      "issue": "DNS root backend key handling is incorrect (tfvars cannot set backend key), risking state collisions between staging/production or incorrect state usage.",
      "why_blocking": "A wrong or shared state key can cause Terraform to manage the wrong environment’s DNS zone/records, leading to production DNS outages or accidental record changes during staging work.",
      "fix": "Add `infrastructure/terraform/dns/environments/{staging,production}/backend.tfvars` with `key = \"dns/<env>.tfstate\"` and require `terraform init -backend-config=...` in all workflows/docs; remove the claim that tfvars sets backend key."
    },
    {
      "location": "§7.7 / §2.3 Cross-root references — `data.aws_lb` selection",
      "issue": "`data.aws_lb` tag filtering/postcondition as written will not work with AWS provider ~> 5.x; DNS root will fail when enabling `api.0xhoneyjar.xyz`.",
      "why_blocking": "Production cutover step 3.3(4) depends on `enable_production_api=true`; if the data source fails, Terraform cannot create the alias record, blocking API DNS cutover and potentially leaving the domain partially migrated.",
      "fix": "Use `data.aws_lbs` with `tags` and enforce exactly one ARN, then read the selected ALB via `data.aws_lb` by ARN (or use an explicit ALB ARN variable passed into DNS root)."
    },
    {
      "location": "§3.3 S3 Object Lock — audit anchors bucket",
      "issue": "Object Lock enablement is missing on the S3 bucket resource; Object Lock configuration cannot be applied unless the bucket was created with Object Lock enabled.",
      "why_blocking": "This is a stateful, compliance-mode retention requirement; failure to manage it correctly either breaks apply/import or leaves audit anchors without the required immutability guarantees, violating the PRD’s safety invariants.",
      "fix": "Add `object_lock_enabled = true` to `aws_s3_bucket.finn_audit_anchors` and ensure the existing bucket was created with Object Lock enabled before attempting import; if not, create a new compliant bucket and migrate data with a documented procedure."
    },
    {
      "location": "§7.1 dns/main.tf — required_providers",
      "issue": "Terraform provider constraint syntax is invalid (`aws = \"~> 5.0\"`).",
      "why_blocking": "Terraform init will fail, preventing any DNS root operations and blocking the DNS migration entirely.",
      "fix": "Use `required_providers { aws = { source = \"hashicorp/aws\", version = \"~> 5.0\" } }`."
    },
    {
      "location": "§8.1 dns-pre-migration.sh — record equivalence validation",
      "issue": "The pre-migration comparison only checks apex for each type and a few specific names; it does not validate critical delegated names like `_acme-challenge` NS records or `agents.*` records, and `dig @dns.gandi.net` may not reflect the authoritative zone for all record types during transition.",
      "why_blocking": "Missing validation of ACME delegation and agent wildcard records can lead to certificate issuance failures or broken subdomains immediately after NS cutover, violating the zero-downtime DNS migration requirement.",
      "fix": "Explicitly compare `_acme-challenge.${DOMAIN}` (NS), `_acme-challenge.agents.${DOMAIN}` (NS), `agents.${DOMAIN}` (A), `*.agents.${DOMAIN}` (CNAME), and `google._domainkey.${DOMAIN}` (TXT when enabled). Also query Gandi’s authoritative nameservers for the zone (from current NS set) rather than a fixed resolver hostname."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1,
  "auto_approved": false
}
