{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Core direction is workable, but there are several ledger/settlement/treasury and payout-state design flaws that will break conservation/solvency or make refunds and retries unsafe in production.",
  "blocking_issues": [
    {
      "location": "§3.3 Treasury Account + §4.2 RevenueDistributionService Extension (reserve funding)",
      "issue": "Treasury reserve is funded by minting new credits (`reserve_funding`) at the same time referrer earnings are minted, which violates conservation and makes solvency meaningless (you can always “fund” the reserve by minting).",
      "why_blocking": "Payout solvency cannot be enforced if the reserve is not backed by real inflows. This creates an accounting hole: every referral earning increases both creator withdrawable supply and reserve supply without any corresponding debit from the original charge proceeds. Under load, you will pay out more than you actually collected.",
      "fix": "Model the reserve as an allocation of the existing charge proceeds, not a second mint. Concretely: when distributing a finalized charge, split the single `totalMicro` into (referrer + commons + community + foundation + reserve if needed) such that the sum equals `totalMicro`, and post ledger entries that move value from the payer/charge source into each destination exactly once. If you need a reserve to back withdrawals, fund it from the foundation share (or a defined fee) by transferring from foundation’s credited amount into the reserve account (a debit+credit pair), not by minting."
    },
    {
      "location": "§4.2 RevenueDistributionService Extension (idempotency + atomicity)",
      "issue": "Idempotency is checked via `SELECT` on `referrer_earnings`, but the subsequent minting and insert are not shown as a single transaction; concurrent calls can double-mint lots and/or double-fund reserve even if the `referrer_earnings` insert later fails.",
      "why_blocking": "Revenue distribution is a hot path; retries and concurrent finalization events happen. A race here creates permanent ledger inflation that cannot be cleanly repaired because the ledger is append-only and the idempotency key is not guaranteed to cover all side effects.",
      "fix": "Wrap the entire referrer-share block in one SQLite transaction with a write lock, and make the `referrer_earnings` row the first write using `INSERT ... ON CONFLICT DO NOTHING` keyed by `(inference_charge_id, rule_version)`. Only if the insert succeeds should you mint the lot(s). Alternatively, rely solely on ledger-level idempotency by enforcing a UNIQUE constraint on `credit_ledger.idempotency_key` (or equivalent) and use that as the single source of truth."
    },
    {
      "location": "§4.3 CreatorPayoutService (payout request transaction + “SELECT FOR UPDATE”)",
      "issue": "SQLite does not support `SELECT ... FOR UPDATE` semantics as written; the design assumes row-level locking/OCC that is not specified in schema, and payout concurrency is >1 (BullMQ concurrency 2).",
      "why_blocking": "Without correct locking, two payout requests can both observe sufficient treasury balance and both debit, or one can partially apply debits and then fail, leaving inconsistent state. This directly breaks the treasury solvency invariant under concurrent access.",
      "fix": "Use SQLite transaction modes explicitly: `BEGIN IMMEDIATE` (or `BEGIN EXCLUSIVE` if needed) for the payout-request critical section so only one writer can proceed. If you want OCC, add a `version INTEGER NOT NULL` column on the treasury account row (or a dedicated `treasury_state` table) and update with `WHERE version = ?` to guarantee atomic compare-and-swap. Also set BullMQ payout execution concurrency to 1 unless you can prove correctness with the chosen locking strategy."
    },
    {
      "location": "§4.3 Payout flow + `payout_requests` schema",
      "issue": "Funds are debited (creator + reserve) before the external payout is created, but there is no compensating credit path for terminal failures/cancellations, and no clear state machine guaranteeing exactly-once burn vs payout execution.",
      "why_blocking": "If NOWPayments call fails permanently, webhook never arrives, or the job crashes after debiting but before creating the provider payout, user funds are stuck/burned. This will cause irrecoverable balance loss and support escalations.",
      "fix": "Implement a two-phase accounting model: (1) place funds in an internal escrow/hold (move from withdrawable lot pool to `withdrawal:pending` pool; similarly reserve to `reserve:held`) and create `payout_requests` in `pending`; (2) only on provider acceptance transition to `processing`; (3) on terminal failure/cancel, release escrow back to original pools via ledger transfers; (4) on completion, finalize by burning/marking withdrawn. Ensure every transition is idempotent and driven by a unique `payout_requests.id`."
    },
    {
      "location": "§4.4 SettlementService (clawback implementation) + §4.3 withdrawable balance query",
      "issue": "Clawback uses `ledger.consumeLot()` on a minted lot and also `ledger.debitAccount()` on treasury, but the treasury side was minted as a separate lot with its own idempotency key and is not linked to the earning; also `consumeLot` implies spending from a lot, which may violate FIFO/lot invariants if the lot has already been partially consumed or if lots are immutable.",
      "why_blocking": "Refunds/clawbacks are guaranteed to happen. Without a correct reversible linkage between earning lots and reserve backing, you cannot reliably reverse pending earnings, and you risk negative balances or broken lot accounting. Additionally, the withdrawable query ties withdrawability to `referrer_earnings.status='settled'` but does not ensure the corresponding lot still has `available_micro` (it might have been consumed by payout/other operations).",
      "fix": "Create an explicit linkage table/columns: store both `earning_lot_id` and `reserve_lot_id` (or ledger entry ids) in `referrer_earnings`. For clawback, post compensating ledger entries that reverse the exact original entries (by referencing those ids) rather than “consume” generically. For withdrawable balance, compute from lots’ `available_micro` filtered by pool and a settled marker, but ensure the settled marker is on the lot/ledger entry itself (e.g., `referrer_earnings.settlement_at` + join on lot id) and that payout consumption reduces `available_micro` correctly."
    },
    {
      "location": "§3.2 credit_ledger entry types + §4.4 settlement markers",
      "issue": "Design introduces `settlement` as an entry type “marker” but settlement is implemented only by updating `referrer_earnings.status`; there is no ledger-level finality record, so the ledger is not the authoritative audit trail for settlement state.",
      "why_blocking": "You explicitly rely on the ledger as immutable audit for financial operations. If settlement/finality lives only in a mutable table, you lose auditability and can’t reconcile balances vs settlement state after incidents or partial restores.",
      "fix": "Either (A) remove the `settlement` ledger type and treat `referrer_earnings` as the authoritative settlement state (then update the SDD and ensure reconciliation tooling), or (B) actually write a ledger entry on settlement that references the earning (e.g., `settlement` entry with metadata `{earning_id, lot_id}`) and make withdrawability depend on presence of that ledger entry (or a derived materialized view)."
    },
    {
      "location": "§3.1 `wallet_links` + §4.5 Wallet link verification (EIP-191)",
      "issue": "`wallet_links.verified_at` is `NOT NULL`, but the flow describes inserting after verifying nonce/timestamp; there is no table to issue nonces prior to verification, and storing the nonce only in `wallet_links` makes it impossible to enforce single-use before insert without a separate nonce registry. Also message canonicalization via `JSON.stringify` is not stable across clients (field order/whitespace), causing signature verification failures.",
      "why_blocking": "Wallet linking will fail intermittently across clients and you cannot safely prevent replay without a proper nonce issuance/consumption mechanism. This becomes a security and UX failure for score rewards attribution.",
      "fix": "Add a `wallet_link_nonces` (or `auth_nonces`) table: `(nonce PRIMARY KEY, account_id, wallet_address, chain_id, issued_at, expires_at, used_at)`; API issues nonce, client signs a canonical string. Use a deterministic message format (EIP-4361 SIWE-style string, or a fixed template string with newline separators) rather than JSON. Insert `wallet_links` with `verified_at` set at verification time; allow `verified_at` nullable only if you support pending links."
    },
    {
      "location": "§4.2 Referral attribution active check (type mismatch) + §4.2 code snippet",
      "issue": "`isAttributionActive(registrationId: string, atTimestamp: string): boolean` does not match usage `this.isAttributionActive(referral, opts.finalizedAt)` and the timestamp types are inconsistent (string vs Date).",
      "why_blocking": "This will ship broken or be “fixed in code” inconsistently, and attribution windows are core to revenue share correctness. Small mismatches here lead to silent misattribution and payout disputes.",
      "fix": "Define a single contract: `isAttributionActive(reg: ReferralRegistration, at: Date): boolean` (or both strings) and enforce UTC parsing. Add tests for boundary conditions (exact expiry instant)."
    },
    {
      "location": "§3.1 `referral_bonuses` table",
      "issue": "Missing foreign keys to `credit_accounts` for `referee_account_id` and `referrer_account_id`, and missing uniqueness/idempotency constraints for `qualifying_action` + `qualifying_action_id` (or per referee) to prevent duplicate bonus grants on retries.",
      "why_blocking": "Bonus granting is asynchronous with retries; without idempotency constraints you will double-grant money. Missing FKs will allow orphaned rows and break joins/analytics/fraud review.",
      "fix": "Add `REFERENCES credit_accounts(id)` for both account columns. Add `UNIQUE(referee_account_id, qualifying_action, qualifying_action_id)` (or whatever the true idempotency key is). If multiple bonuses per referee are allowed, scope uniqueness accordingly and include `campaign_id` if needed."
    },
    {
      "location": "§4.7 FraudCheckService risk signals",
      "issue": "Fraud signals require IP/user-agent/fingerprint data, but no data model or event capture path is specified (no table/columns, no request context persistence).",
      "why_blocking": "Signup bonus fraud prevention is a stated requirement and a dependency for delayed granting. Without persisted signals, the fraud system cannot function beyond the current request, and cron-based delayed processing cannot evaluate historical clusters.",
      "fix": "Add an `auth_events`/`referral_events` table capturing `account_id`, `ip`, `ip_prefix`, `user_agent_hash`, `fingerprint_hash`, `event_type`, `created_at`, and indexes for the cluster queries. Ensure privacy constraints (hashing + retention policy). Wire API layer to write these events."
    }
  ],
  "question": null,
  "iteration": 1
}
