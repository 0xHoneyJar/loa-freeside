{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Two major issues found: the replay hard limit can be bypassed with negative limits, and consistency verification uses different transactions causing inconsistent snapshots.",
  "issues": [
    {
      "severity": "major",
      "file": "packages/services/event-sourcing-service.ts",
      "line": 174,
      "description": "Hard 10k limit can be bypassed with negative limits because Math.min preserves negative values, allowing LIMIT -1 (no limit) in PostgreSQL.",
      "current_code": "```typescript\n  const effectiveLimit = Math.min(limit, MAX_REPLAY_EVENTS);\n```",
      "fixed_code": "```typescript\n  const normalizedLimit = Number.isFinite(limit) ? Math.floor(limit) : MAX_REPLAY_EVENTS;\n  const effectiveLimit = Math.min(Math.max(normalizedLimit, 0), MAX_REPLAY_EVENTS);\n```",
      "explanation": "Clamping the limit to a non-negative integer prevents LIMIT -1 from disabling the hard cap while still enforcing the 10k maximum."
    },
    {
      "severity": "major",
      "file": "packages/services/event-sourcing-service.ts",
      "line": 236,
      "description": "verifyConsistency performs replay and balance checks in separate transactions, producing inconsistent snapshots and false drift reports under concurrent writes.",
      "current_code": "```typescript\nexport async function verifyConsistency(\n  pool: Pool,\n  communityId: string,\n): Promise<ConsistencyResult> {\n  // Replay all sequenced events (up to 10k limit)\n  const replayedStates = await replayState(pool, communityId);\n\n  return withCommunityScope(communityId, pool, async (client) => {\n    // Fetch actual balances from lot_balances view\n    const balances = await client.query<{\n      lot_id: string;\n      remaining_micro: string;\n    }>(\n      `SELECT lot_id, remaining_micro\n       FROM lot_balances\n       WHERE community_id = $1`,\n      [communityId],\n    );\n\n    const actualMap = new Map<string, bigint>();\n    for (const row of balances.rows) {\n      actualMap.set(row.lot_id, BigInt(row.remaining_micro));\n    }\n\n    const drifts: LotDrift[] = [];\n    let totalDriftMicro = 0n;\n\n    for (const [lotId, state] of replayedStates) {\n      const actual = actualMap.get(lotId) ?? 0n;\n      const drift = state.remainingMicro - actual;\n\n      if (drift !== 0n) {\n        const absDrift = drift < 0n ? -drift : drift;\n        drifts.push({\n          lotId,\n          replayedRemaining: state.remainingMicro,\n          actualRemaining: actual,\n          driftMicro: drift,\n        });\n        totalDriftMicro += absDrift;\n      }\n    }\n\n    return {\n      communityId,\n      lotsChecked: replayedStates.size,\n      lotsConsistent: replayedStates.size - drifts.length,\n      lotsDrifted: drifts.length,\n      drifts,\n      totalDriftMicro,\n    };\n  });\n}\n```",
      "fixed_code": "```typescript\nasync function replayStateWithClient(\n  client: PoolClient,\n  communityId: string,\n  fromSequence: bigint = 1n,\n  limit: number = MAX_REPLAY_EVENTS,\n): Promise<Map<string, ReplayedLotState>> {\n  const normalizedLimit = Number.isFinite(limit) ? Math.floor(limit) : MAX_REPLAY_EVENTS;\n  const effectiveLimit = Math.min(Math.max(normalizedLimit, 0), MAX_REPLAY_EVENTS);\n\n  const result = await client.query<{\n    id: string;\n    lot_id: string;\n    community_id: string;\n    entry_type: string;\n    amount_micro: string;\n    sequence_number: string;\n    correlation_id: string;\n    causation_id: string;\n    created_at: Date;\n  }>(\n    `SELECT id, lot_id, community_id, entry_type, amount_micro,\n            sequence_number, correlation_id, causation_id, created_at\n     FROM lot_entries\n     WHERE community_id = $1\n       AND sequence_number IS NOT NULL\n       AND sequence_number >= $2\n     ORDER BY sequence_number ASC\n     LIMIT $3`,\n    [communityId, fromSequence.toString(), effectiveLimit],\n  );\n\n  const lotStates = new Map<string, ReplayedLotState>();\n\n  for (const row of result.rows) {\n    const lotId = row.lot_id;\n    if (!lotId) continue; // governance entries without lot_id\n\n    let state = lotStates.get(lotId);\n    if (!state) {\n      state = {\n        lotId,\n        creditedMicro: 0n,\n        debitedMicro: 0n,\n        expiredMicro: 0n,\n        creditBackMicro: 0n,\n        governanceDebitMicro: 0n,\n        governanceCreditMicro: 0n,\n        remainingMicro: 0n,\n        entryCount: 0,\n      };\n      lotStates.set(lotId, state);\n    }\n\n    const amount = BigInt(row.amount_micro);\n    state.entryCount++;\n\n    switch (row.entry_type) {\n      case 'credit':\n        state.creditedMicro += amount;\n        state.remainingMicro += amount;\n        break;\n      case 'credit_back':\n        state.creditBackMicro += amount;\n        state.remainingMicro += amount;\n        break;\n      case 'debit':\n        state.debitedMicro += amount;\n        state.remainingMicro -= amount;\n        break;\n      case 'expiry':\n        state.expiredMicro += amount;\n        state.remainingMicro -= amount;\n        break;\n      case 'governance_debit':\n        state.governanceDebitMicro += amount;\n        state.remainingMicro -= amount;\n        break;\n      case 'governance_credit':\n        state.governanceCreditMicro += amount;\n        state.remainingMicro += amount;\n        break;\n    }\n  }\n\n  return lotStates;\n}\n\nexport async function replayState(\n  pool: Pool,\n  communityId: string,\n  fromSequence: bigint = 1n,\n  limit: number = MAX_REPLAY_EVENTS,\n): Promise<Map<string, ReplayedLotState>> {\n  return withCommunityScope(communityId, pool, async (client) => {\n    return replayStateWithClient(client, communityId, fromSequence, limit);\n  });\n}\n\nexport async function verifyConsistency(\n  pool: Pool,\n  communityId: string,\n): Promise<ConsistencyResult> {\n  return withCommunityScope(communityId, pool, async (client) => {\n    // Replay within the same transaction snapshot\n    const replayedStates = await replayStateWithClient(client, communityId);\n\n    const balances = await client.query<{\n      lot_id: string;\n      remaining_micro: string;\n    }>(\n      `SELECT lot_id, remaining_micro\n       FROM lot_balances\n       WHERE community_id = $1`,\n      [communityId],\n    );\n\n    const actualMap = new Map<string, bigint>();\n    for (const row of balances.rows) {\n      actualMap.set(row.lot_id, BigInt(row.remaining_micro));\n    }\n\n    const drifts: LotDrift[] = [];\n    let totalDriftMicro = 0n;\n\n    for (const [lotId, state] of replayedStates) {\n      const actual = actualMap.get(lotId) ?? 0n;\n      const drift = state.remainingMicro - actual;\n\n      if (drift !== 0n) {\n        const absDrift = drift < 0n ? -drift : drift;\n        drifts.push({\n          lotId,\n          replayedRemaining: state.remainingMicro,\n          actualRemaining: actual,\n          driftMicro: drift,\n        });\n        totalDriftMicro += absDrift;\n      }\n    }\n\n    return {\n      communityId,\n      lotsChecked: replayedStates.size,\n      lotsConsistent: replayedStates.size - drifts.length,\n      lotsDrifted: drifts.length,\n      drifts,\n      totalDriftMicro,\n    };\n  });\n}\n```",
      "explanation": "Replaying and reading balances within the same transaction snapshot ensures consistency and avoids false drift from concurrent writes. The helper also centralizes the hardened limit logic."
    }
  ],
  "fabrication_check": {
    "passed": true,
    "concerns": []
  },
  "iteration": 1
}
