{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Most iteration-1 blockers were addressed correctly, but two fixes introduce truly blocking problems: the backfill DO/COMMIT pattern is invalid SQL for PostgreSQL, and the admin_audit_log privilege model still allows cross-tenant audit log reads by the app role.",
  "previous_issues_status": [
    {
      "original_issue": "0012 purpose column added as NOT NULL DEFAULT could block; needed phased online approach",
      "status": "fixed",
      "notes": "Now uses nullable add + backfill + DEFAULT + CHECK NOT VALID + VALIDATE, and explicitly avoids SET NOT NULL. That’s the correct online pattern."
    },
    {
      "original_issue": "0014 partial index predicate used NOW() (non-immutable) so migration would fail",
      "status": "fixed",
      "notes": "NOW() removed from predicate; effective_until handled at query time. DDL is valid."
    },
    {
      "original_issue": "0015 trigger referenced prevent_mutation() but function missing",
      "status": "fixed",
      "notes": "prevent_mutation() is defined before trigger. DDL will apply."
    },
    {
      "original_issue": "0013 correlation_id default requires pgcrypto; and CONCURRENTLY indexes require non-transactional migration",
      "status": "fixed",
      "notes": "CREATE EXTENSION IF NOT EXISTS pgcrypto added; migration split into 0013a/0013b with transaction:false for CONCURRENTLY is correct."
    },
    {
      "original_issue": "community_operations view fragmented operations by grouping on purpose/entry_type; not correlation-aware",
      "status": "fixed",
      "notes": "Now groups strictly by (community_id, correlation_id) and provides JSON aggregates. This matches SKP-002 intent."
    },
    {
      "original_issue": "Replay semantics inconsistent; expire double-subtract risk; governance lot_id NULL handling; enforce lot_id NOT NULL for economic types",
      "status": "fixed",
      "notes": "Canonical posting model is now explicit; expire uses explicit amount_micro; CHECK constraint enforces lot_id for non-governance. Replay switch aligns with the table."
    },
    {
      "original_issue": "Governance approve(): BigInt conversion from JSONB numeric could throw / lose precision",
      "status": "fixed",
      "notes": "limit_micro required as string with Zod validation; approve() uses BigInt(string). This resolves the precision/throw risk."
    },
    {
      "original_issue": "RLS completeness: current_setting missing_ok; admin_audit_log had no RLS/privilege model; risk of bypass/outages",
      "status": "not_fixed",
      "notes": "Tenant-table policies now use current_setting(..., true)+COALESCE which is good. However, admin_audit_log is still readable by app_role per the stated GRANT, which is a cross-tenant exposure for any endpoint/path that can query it (or future code). This remains a SKP-007-class blocker unless app_role SELECT is removed or RLS is added with a separate privileged reader role."
    },
    {
      "original_issue": "Sequencing contention mitigation not concretely specified for Tier 2/3",
      "status": "fixed",
      "notes": "Tier 2 advisory lock and Tier 3 range allocation SQL are specified with monotonic/no-duplicate guarantees and gap tolerance. That satisfies SKP-003."
    },
    {
      "original_issue": "CommunityId in path vs actor.community_id missing explicit cross-check (IDOR class)",
      "status": "fixed",
      "notes": "requireCommunityMatch() middleware added with platform-admin audited bypass. This addresses the multi-tenant guard requirement."
    }
  ],
  "new_blocking_concerns": [
    {
      "location": "3.2.1 Migration 0012 Phase 2 backfill DO $$ ... COMMIT; inside loop",
      "description": "The provided backfill snippet is not valid PostgreSQL: you cannot issue COMMIT inside a DO block (PL/pgSQL DO runs in a single transaction). As written, operators following the SDD will hit errors and/or attempt a long-running single transaction backfill that can bloat/lock and threaten production.",
      "why_blocking": "This is the operational heart of the “online” migration. If the documented approach fails or runs as one huge transaction, it can cause severe bloat, long lock retention, replication lag, and potentially stall writes—contradicting the zero-downtime requirement.",
      "fix": "Replace the DO-block example with an application-side or psql-side batch loop that commits between batches (each batch is its own transaction). Example operational guidance: run repeated statements like `UPDATE ... WHERE id IN (SELECT id ... LIMIT 5000 FOR UPDATE SKIP LOCKED);` in a script that COMMITs each iteration, with lock_timeout/statement_timeout set. Alternatively, use a server-side PROCEDURE (CREATE PROCEDURE) which can COMMIT, but DO cannot."
    },
    {
      "location": "1.9 Security Architecture + 3.2.4 Migration 0015 admin_audit_log privileges",
      "description": "The SDD grants SELECT on admin_audit_log to app_role while also stating the table has no RLS. That makes the entire platform audit log readable by the application DB role (cross-tenant), which is a data exposure risk and violates the stated intent of platform-level restricted access.",
      "why_blocking": "Any compromised app path, SQL injection, misrouted query, or future feature that exposes audit logs would leak cross-tenant sensitive audit data. With no RLS, DB is not enforcing tenant isolation here. This is a security blocker (SKP-007 class).",
      "fix": "Remove SELECT from app_role: `REVOKE ALL ON admin_audit_log FROM app_role; GRANT INSERT ON admin_audit_log TO app_role;` and create a separate `audit_reader_role` (or platform-admin service role) with SELECT. If the app must read its own audit entries, then enable RLS on admin_audit_log and scope by community_id (and handle NULL community_id rows carefully), or expose reads only via a separate privileged connection with explicit platform-admin authorization."
    }
  ],
  "iteration": 2
}
