{
  "verdict": "CHANGES_REQUIRED",
  "summary": "4/5 prior blockers are addressed with acceptable verification gates and documentation, but the revised ADR-001 “type identity” guard is still fundamentally incorrect and will either fail to compile or provide no protection, making AC-1.6 unenforceable in CI.",
  "previous_issues_status": [
    {
      "original_issue": "Barrel re-exports governance subpath symbols without verifying they exist at runtime (TASK_TYPES, validateTaskCohortUniqueness)",
      "status": "fixed",
      "notes": "The added mandatory runtime export verification gate using dynamic import of the provider entrypoints is sufficient to prevent deterministic contract-spec failures, and the documented fallback actions (move entrypoint / type-only / remove+note) are appropriate."
    },
    {
      "original_issue": "Assumed computeScoringPathHash and SCORING_PATH_GENESIS_HASH are root exports; contract.json may point at wrong entrypoint",
      "status": "fixed",
      "notes": "The SDD now explicitly requires verifying the root export surface and moving both the barrel import path and contract.json entry to the correct subpath if needed. This addresses the CI-failure mode."
    },
    {
      "original_issue": "evaluation_geometry exposure relied on an assumption that Constraint is already exported from the freeside barrel",
      "status": "fixed",
      "notes": "The revised §3.3 makes exposure conditional on verifying existing barrel exports and requires adding Constraint/ConstraintSchema (and contract entry if runtime) if missing. That resolves the schema-access risk."
    },
    {
      "original_issue": "Rebuild script violates 'schema-only' intent and can introduce non-determinism/supply-chain risk",
      "status": "fixed",
      "notes": "§3.5.3 now clearly states the trust boundary (rebuilt dist is what executes) and adds concrete verification requirements (exact ref, DIST_HASH recording/compare, tag compatibility, toolchain pin/limitation). This is sufficient for this cycle’s stated constraints."
    },
    {
      "original_issue": "ADR-001 guard was brittle (grep-based) and could false-fail/false-pass; needed AST-based or stronger enforcement",
      "status": "not_fixed",
      "notes": "The new two-layer approach still has a truly blocking flaw: Layer 1 attempts `expect(BarrelTaskType).toBe(RoutingTaskType)` while importing `TaskType` as a value. In the SDD itself, TaskType is used as a type-only import in routing code, and in most TS setups TaskType is not a runtime value. This will either (a) fail TypeScript compilation ('TaskType only refers to a type, but is being used as a value') or (b) be meaningless if it compiles due to some unrelated runtime export. Either way it does not reliably enforce that the *type identity* used in routing remains the routing-policy variant. Layer 2 is still text scanning (now scoped), which can still false-pass via indirect usage or aliasing and does not meet the original goal of robust enforcement."
    }
  ],
  "new_blocking_concerns": [
    {
      "location": "§4.2 ADR-001 Import Guard Test — Layer 1 type identity assertion",
      "description": "The proposed identity test treats TaskType as a runtime value and compares object reference equality, which is not valid for a TypeScript type alias/union and will likely not compile or will provide no real guarantee.",
      "why_blocking": "AC-1.6 is a hard constraint and is enforced via CI tests. As written, this guard is either a compile-time error (blocking the build) or a false sense of safety (test passes without actually preventing governance TaskType leakage). That reintroduces the original blocker: the guard can’t be trusted to prevent accidental coupling in routing/mapping code paths.",
      "fix": "Replace Layer 1 with a check that is actually enforceable:\n- If you want a runtime identity check, compare *schemas* (e.g., `TaskTypeSchema`) that are known runtime exports, not the `TaskType` type. Only do this if both routing-policy and governance variants have distinct runtime schema objects.\n- Otherwise, implement the guard using TypeScript AST (ts-morph / compiler API) over the curated ROUTING_MODULES list to detect any import (type or value) from `@0xhoneyjar/loa-hounfour/governance` and any identifier usage of `GovernanceTaskType`/`GovernanceReputationEvent` (including aliased imports).\n- Minimal acceptable alternative (still deterministic): in each routing module, enforce an allowlist of import specifiers and fail if any specifier matches `/Governance(TaskType|ReputationEvent)/` or any module specifier contains `/governance`.\nThis restores a CI-enforceable, non-brittle guard without requiring whole-repo grep."
    }
  ],
  "iteration": 2
}
