{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Most previously-blocking issues were fixed (artifact-bound verification, determinism framing, import access control, dual-version replay strategy, export-map alignment, and staged dual-parse), but two new/remaining blocking problems exist: the rebuild script’s clone/checkout is not actually pinned to the expected SHA, and the rollback env var name contradicts the implementation.",
  "previous_issues_status": [
    {
      "original_issue": "Supply-chain verification was TOCTOU / verified SHA but required from workspace node_modules (wrong artifact)",
      "status": "fixed",
      "notes": "Now builds in an isolated temp clone, embeds dist/SOURCE_SHA, computes a dist hash, and validates resolution against the built dist path rather than node_modules. This correctly binds verification to the artifact being produced/consumed."
    },
    {
      "original_issue": "Determinism claim incorrectly used `tsc --strict` as a reproducibility control",
      "status": "fixed",
      "notes": "SDD now correctly states strict is not determinism, and adds real controls (pinned Node/TS, npm ci/frozen lockfile, stable tsconfig, SOURCE_DATE_EPOCH)."
    },
    {
      "original_issue": "Import access control enforcement used the wrong ESLint mechanism (`import/no-restricted-paths`)",
      "status": "fixed",
      "notes": "Switched to ESLint core `no-restricted-imports` with specifier patterns and allowlisted overrides, plus CI AST fallback. This is implementable and matches the requirement."
    },
    {
      "original_issue": "Boundary payload replay required comparing v7.0.0 vs v7.9.2 but only one version can be installed; harness not specified",
      "status": "fixed",
      "notes": "Replaced dual-install with a golden-baseline strategy (generate under v7.0.0, commit, then compare under v7.9.2). This is implementable and meets AC-1.6 intent."
    },
    {
      "original_issue": "Barrel re-exports may use wrong specifiers vs export map (root vs subpath), causing runtime resolution failures",
      "status": "fixed",
      "notes": "SDD explicitly requires aligning to v7.9.2 exports map and adds an export-map validation test that imports from the exact specifiers used. That addresses the runtime failure risk."
    },
    {
      "original_issue": "parseMicroUsd dual-parse wrapper could prevent safe cutover (legacy fallback forever) and lacked operational gating",
      "status": "fixed",
      "notes": "Now has explicit staged modes (legacy/shadow/enforce), a discriminated union return, caller responsibility by boundary type, metrics + threshold, timebox to remove shadow, and a kill-switch. This is operationally sound."
    }
  ],
  "new_blocking_concerns": [
    {
      "location": "SDD §3.2 FR-2 Rebuild Script Update — Step 1/2 (git clone/checkout)",
      "description": "The script uses `git clone --depth 1` and then `git checkout \"$EXPECTED_SHA\"`. With a depth-1 clone of the default branch tip, the expected commit SHA will often not exist locally, causing checkout to fail (or forcing an implicit fetch that is not specified). This makes the rebuild pipeline unreliable and can block the upgrade or lead engineers to weaken verification to “make it work.”",
      "why_blocking": "FR-2 is a hard security requirement (AC-2.4). If the script cannot reliably check out the pinned SHA, the supply-chain verification mechanism will fail in CI/automation, blocking the release or encouraging insecure workarounds.",
      "fix": "Make the clone fetch the exact commit deterministically. For example:\n- Option A (recommended): `git init`, `git remote add origin`, `git fetch --depth 1 origin $EXPECTED_SHA`, then `git checkout --detach FETCH_HEAD`.\n- Option B: `git clone --no-checkout $HOUNFOUR_REPO $CLONE_DIR && cd $CLONE_DIR && git fetch --depth 1 origin $EXPECTED_SHA && git checkout --detach $EXPECTED_SHA`.\nAlso add `set -euo pipefail` and explicit error messages on fetch/checkout failure."
    },
    {
      "location": "SDD §7 Rollback Strategy vs §3.6 FR-6 parseMicroUsd rollout",
      "description": "Rollback table specifies `PARSE_MICRO_USD_LEGACY=true`, but the implementation uses `PARSE_MICRO_USD_MODE=legacy|shadow|enforce`. This mismatch will cause the documented kill-switch to not work during an incident.",
      "why_blocking": "Rollback must be practical and correct per the verification checklist. In an outage caused by boundary tightening, operators will follow the runbook; if the env var is wrong, the service will continue rejecting inputs and recovery will fail.",
      "fix": "Unify on a single control. Either (a) update rollback docs to `PARSE_MICRO_USD_MODE=legacy`, or (b) support both by implementing `if (process.env.PARSE_MICRO_USD_LEGACY === 'true') mode='legacy'` as a backward-compatible alias, and document precedence."
    }
  ],
  "iteration": 2
}
