{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Sprint 5 is close, but as written it has a couple of migration-safety and test-execution gaps that can cause the implementation to fail or ship a non-idempotent/unsafe migration in production.",
  "blocking_issues": [
    {
      "location": "Sprint 5 — Task 5.1 acceptance criteria (idempotency + execution order)",
      "issue": "The proposed SQL sequence `DROP TABLE credit_lots` while `foreign_keys = OFF` can silently delete the parent table while child tables still exist, and the plan does not require validating schema-level FK targets after the rebuild inside the migration itself.",
      "why_blocking": "With FK enforcement disabled, dropping `credit_lots` is allowed even if `credit_ledger/reservation_lots/credit_debts` reference it. If anything fails between DROP and RENAME (or if the migration is interrupted), the DB can be left in a broken state. Also, `foreign_key_check` only checks row-level integrity; it will not detect that FKs now point at a non-existent table name. This is exactly the class of bug you’re fixing—so the migration needs an in-migration schema validation step or it can still ship broken under partial-failure conditions.",
      "fix": "Amend Task 5.1 to (a) keep the old table until the new one is fully populated and validated, and (b) add an explicit schema-level FK target verification step in `up()` after the rename. Concretely: use a safer pattern like `CREATE _new; INSERT; CREATE indexes on _new (or after rename); ALTER TABLE credit_lots RENAME TO _old; ALTER TABLE _new RENAME TO credit_lots; DROP TABLE _old;` (so you only drop the old table at the end). Then add a check that `PRAGMA foreign_key_list(credit_ledger)` (and other tables) reference `credit_lots` and that `sqlite_master` contains the referenced table names. Make this part of the migration’s acceptance criteria."
    },
    {
      "location": "Sprint 5 — Task 5.1 acceptance criteria (idempotency requirement)",
      "issue": "The plan requires the migration to be idempotent (“running against a DB that already has tba_deposit … does not error”), but the described SQL (`CREATE TABLE _credit_lots_new`, `INSERT ... SELECT *`, `DROP TABLE credit_lots`) is not idempotent without additional guards and can fail on re-run or on partially-migrated states.",
      "why_blocking": "SQLite migrations in production are commonly re-run in dev/test, and partial application can happen (crash mid-migration). Without explicit handling, re-running can hit: `_credit_lots_new already exists`, `credit_lots missing`, or duplicate index names. This will cause CI failures when tests create DBs in different ways, and it can cause operational failure if a migration is retried.",
      "fix": "Define the exact idempotency strategy in the task: either (1) explicitly drop temp tables if present (`DROP TABLE IF EXISTS _credit_lots_new;`) and use `IF EXISTS/IF NOT EXISTS` for indexes where possible, plus detect whether `tba_deposit` is already in the CHECK and early-return; or (2) remove the idempotency requirement and instead assert migrations are run exactly once (but then update acceptance criteria and test harness accordingly). Given your requirement, add explicit guards for `_credit_lots_new`, `_credit_lots_058_backup/_old`, and index recreation naming collisions."
    },
    {
      "location": "Sprint 5 — Task 5.3 acceptance criteria (migration runner scope)",
      "issue": "Task 5.3 says “Runs all migrations in order (030 through 060+)” which is ambiguous and likely wrong for a repo with 60+ migrations; it risks not actually reproducing the production sequence that triggers the FK corruption.",
      "why_blocking": "If the test doesn’t run the full real migration chain (from 001 or whatever the actual baseline is), it may miss the exact schema state where 060 runs and therefore fail to catch regressions. This can lead to a false sense of safety and a reintroduction of the bug.",
      "fix": "Change acceptance criteria to: “Runs the exact same migration runner used in production from the first migration through the latest.” If you truly need a subset, specify the precise starting migration that creates the involved tables and constraints, and assert the schema version before/after. Make the test fail if any migration is skipped."
    },
    {
      "location": "Sprint 5 — Task 5.2 sequencing vs Sprint 4 artifacts",
      "issue": "Task 5.2 references `cross-system-conservation.test.ts` and `entry-types-consistency.test.ts` workarounds, but those files are also created/modified in earlier sprints; Sprint 5 is marked “independent” yet depends on those files existing in the described form.",
      "why_blocking": "If Sprint 5 is executed before Sprints 1–4 (as allowed by the plan), Task 5.2 may not apply cleanly (file paths/content may differ or not exist yet), causing the sprint to fail or forcing unplanned rework.",
      "fix": "Either (a) declare Sprint 5 depends on Sprints 1–4 (or at least on the existence of those tests), or (b) rewrite Task 5.2 acceptance criteria to be conditional: remove workarounds wherever they exist in the current codebase, and ensure all tests pass with FK ON—without hardcoding specific line ranges/files that may not exist yet."
    }
  ],
  "question": "",
  "iteration": 1
}
