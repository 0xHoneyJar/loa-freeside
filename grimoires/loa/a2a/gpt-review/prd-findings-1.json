{
  "verdict": "CHANGES_REQUIRED",
  "summary": "This PRD is close, but it contains a few contradictions and unverifiable/incorrect success criteria that would either block completion or allow a “green” migration that silently breaks wire compatibility and conservation semantics.",
  "blocking_issues": [
    {
      "location": "Goals G-1 + FR-1 + Scope (Dependency bump) + Technical Context (Current Integration Points)",
      "issue": "Contradictory versioning strategy: G-1 requires `^7.0.0` in package.json, but FR-1/S3 require GitHub tag installs (`github:...#v7.0.0`), which do not behave like semver ranges and won’t satisfy “^7.0.0”.",
      "why_blocking": "You can’t meet the stated measurable goal as written; CI drift detection and upgrade procedure also depend on whether semver ranges are actually in use. This can stall the project in review/acceptance even if the code works.",
      "fix": "Change G-1 metric to match the constraint: e.g. “dependency resolves to tag v7.0.0 (GitHub install) and `CONTRACT_VERSION === '7.0.0'`”. If you truly need semver ranges, require publishing to npm (but that’s out of scope), or adopt a semver-capable Git dependency strategy explicitly (e.g., commit SHA + separate expected version constant) and update G-4 accordingly."
    },
    {
      "location": "NFR-2 + NFR-3 + FR-5 (trust_scopes) + FR-6 (coordination schema) + Success Criteria #8",
      "issue": "“Zero runtime regressions / zero downtime / invisible to production” conflicts with explicitly changing wire-visible fields and schemas, while Phase 4 (cross-system E2E) is out of scope. In particular, trust_scopes and coordination schema are boundary contracts; changing them can break consumers even if arrakis tests pass.",
      "why_blocking": "This migration can ship a breaking change at JWT and coordination boundaries without any in-scope verification that downstream/upstream systems accept it. Declaring “no runtime behavior changes” is not enforceable with only arrakis-local tests, and could lead to a production outage (project failure) despite meeting local acceptance criteria.",
      "fix": "Narrow the claim: replace “no runtime regressions / invisible to production” with “no arrakis-internal behavioral regressions; boundary changes are version-gated.” Add an explicit in-scope requirement to maintain backward-compatible decoding/validation at boundaries (e.g., accept both `trust_level` and `trust_scopes` during a transition, or gate by `CONTRACT_VERSION`/protocol negotiation) and define how arrakis behaves when interacting with pre-v7 peers (even if peers aren’t upgraded in this phase)."
    },
    {
      "location": "FR-5: Breaking Change — trust_scopes Migration (P1) + Goals G-3 (P0) + Review Focus #2",
      "issue": "Priority mismatch: handling both breaking changes is a P0 goal (G-3), but both breaking-change FRs are P1. Also FR-5’s premise (“0 grep matches so impact likely limited”) is unsafe because the break is in JWT claim schemas/types and can manifest at runtime without local string matches.",
      "why_blocking": "This invites shipping Phase 3 without actually addressing the two stated breaking changes, or treating them as optional. It also risks missing runtime schema incompatibilities because the audit is framed around TS source grep rather than boundary payloads.",
      "fix": "Promote FR-5 and FR-6 to P0 (or downgrade G-3 from P0, but that contradicts the stated focus). Update FR-5 to require explicit verification of JWT encode/decode compatibility: add tests that serialize a v7 token and validate claims shape, and (if backward-compat is required) tests that accept legacy tokens or explicitly reject them with a documented error."
    },
    {
      "location": "FR-7 (CI Drift Detection via Semver) + Goals G-4 + Risks table + Dependency constraint (GitHub tag install)",
      "issue": "Semver-based drift detection is underspecified/possibly incorrect under GitHub tag installs. Asserting `CONTRACT_VERSION` major matches expected does not detect drift if the tag is moved/retagged, or if GitHub dependency resolution yields a different commit with the same version string.",
      "why_blocking": "You can end up with silent protocol drift while CI still passes, defeating the stated purpose of replacing hash pinning. This is exactly the failure mode vendoring was preventing.",
      "fix": "Define what “drift” means under GitHub installs and test for it. Options: (a) keep a commit SHA pin (or lockfile integrity) plus assert `CONTRACT_VERSION`; (b) assert the resolved git commit in lockfile matches an expected commit for v7.0.0; or (c) require signed tags and verify tag object hash. Update FR-7 acceptance criteria to check the actual resolved source identity, not just a version constant."
    },
    {
      "location": "NFR-4 (Test Coverage Preservation) + FR-2 requirements/acceptance + FR-7 requirements + Review Focus #7",
      "issue": "“No reduction in test count” is incompatible with explicitly deleting redundant equivalence tests and hash-pinning fixtures unless you add replacement tests. The PRD doesn’t specify what new tests replace them, only that they “may be added”.",
      "why_blocking": "This can deadlock acceptance: either you keep meaningless tests (equivalence against same source) or you violate NFR-4. It also risks teams gaming the metric (adding low-value tests) to keep the count constant.",
      "fix": "Replace the requirement with a measurable quality gate that survives the migration: e.g., “no reduction in statement/branch coverage for protocol modules” or “property-test count preserved; redundant equivalence/hash tests replaced 1:1 with canonical-only validation tests (e.g., schema validation, exported vector tests, or snapshot tests of canonical state machine IDs).” If you keep test-count, explicitly require replacement tests and list them."
    },
    {
      "location": "FR-3 (Conservation Property Migration) + Goals G-5 + Success Criteria #4/#5 + Review Focus #4",
      "issue": "Conservation equivalence is asserted but not actually defined/measurable: “map I-1..I-14 to canonical equivalent” doesn’t guarantee semantic equivalence, and “fix tests to match canonical semantics” can mask real regressions (micro-USD leakage) by changing the oracle.",
      "why_blocking": "This is the core safety property. If the canonical evaluator differs subtly (rounding, sign conventions, event ordering), updating tests to match canonical could accept a behavior that violates arrakis’s intended conservation invariants or vice versa. That’s a project-failure risk because billing correctness is the platform’s trust anchor.",
      "fix": "Add an explicit equivalence strategy: require a dual-run period in tests where the same generated traces are checked by both (old local evaluator and canonical) and must agree, except for an explicitly enumerated, reviewed diff list. If the local evaluator is being deleted, freeze it in a test-only snapshot for comparison during this cycle. Also require at least one end-to-end conservation invariant expressed as a conserved quantity over event streams (e.g., sum of debits/credits in MicroUSD) with property-based generation, independent of either evaluator implementation."
    },
    {
      "location": "FR-6 Acceptance Criteria + NFR-2 + Scope discipline (Phase 3 only)",
      "issue": "“Version negotiation endpoints return v7.0.0” is ambiguous and potentially wrong for Phase 3: if negotiation is meant to interoperate with older peers (Phase 2 not done), always returning v7 may break compatibility; if it’s just reporting local version, it’s not negotiation.",
      "why_blocking": "You could implement the wrong behavior: either break cross-service coordination by refusing older versions, or implement a no-op “negotiation” that doesn’t protect boundaries. Either outcome undermines the stated purpose of coordination schema migration.",
      "fix": "Define negotiation behavior precisely for Phase 3: e.g., “/compat returns supported range [min,max] and selects highest common version; during Phase 3, arrakis supports v7 and (optionally) v4.6 compatibility mode for inbound messages.” If backward support is not required, explicitly state that arrakis will reject pre-v7 coordination messages with a specific error and that this is safe because no pre-v7 peers will call it (but that conflicts with Phase 2 out-of-scope unless you have isolation)."
    }
  ],
  "question": "",
  "iteration": 1
}
