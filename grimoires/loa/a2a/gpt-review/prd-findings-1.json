{
  "verdict": "CHANGES_REQUIRED",
  "summary": "As written, this PRD will likely break S2S compatibility and/or fail CI because it asserts “zero breaking changes” while simultaneously requiring a hard contract-version gate and a 73× conformance-vector jump without a workable compatibility/rollout plan.",
  "blocking_issues": [
    {
      "location": "NFR-1 (Zero Breaking Changes) vs FR-8 / G-6 (provider_version_range >=8.2.0, CONTRACT_VERSION bump, validateCompatibility window tightened)",
      "issue": "The PRD claims “zero breaking changes,” but it explicitly introduces a breaking interoperability change by rejecting v7.x peers via contract/JWT version negotiation.",
      "why_blocking": "Even if the TypeScript build compiles, production-like integration between arrakis and loa-finn will fail immediately unless loa-finn upgrades in lockstep. That is a breaking change in the distributed system contract, and the PRD currently treats the loa-finn upgrade as out-of-scope while simultaneously requiring fail-fast rejection of v7.x peers.",
      "fix": "Either (A) change the requirement to a compatibility window/dual-accept period (e.g., accept >=7.11.0 <9 with feature-gated commons usage) and define a deprecation timeline, or (B) move the loa-finn coordinated upgrade into in-scope with an explicit rollout plan, gating, and a CI integration check that proves negotiation succeeds end-to-end before merging."
    },
    {
      "location": "Section 6 Out of Scope: “loa-finn v8.2.0 coordinated upgrade — Separate repo” vs Section 3/FR-8/Risks",
      "issue": "Coordination with loa-finn is treated as a dependency but not made executable: no acceptance criteria, no sequencing, no rollback/temporary widening plan is actually required by the PRD.",
      "why_blocking": "This creates a high probability of landing arrakis changes that cannot communicate with loa-finn (hard failure at auth/negotiation). In distributed protocol upgrades, “separate repo” is not a mitigation; it’s a failure mode unless the PRD enforces a coordination gate.",
      "fix": "Add a blocking release criterion: ‘Do not merge unless loa-finn main is pinned to >=8.2.0 OR arrakis validateCompatibility accepts 7.11.0 during a defined window.’ Include a concrete sequence (who upgrades first), and a rollback plan (revert provider_version_range / widen window) if negotiation fails."
    },
    {
      "location": "FR-9 / G-7 / Risk table: conformance vectors 3 → 219",
      "issue": "CI impact is materially underestimated and the PRD doesn’t define how conformance vectors are executed (runtime, parallelism, caching, flake policy, time budget).",
      "why_blocking": "A 73× increase can easily blow CI time limits, cause intermittent failures (hash/canonicalization differences, clock-dependent TTL vectors), or block merges. Without an explicit CI strategy and pass/fail policy, the upgrade can stall indefinitely even if code is correct.",
      "fix": "Add explicit non-functional acceptance criteria: max CI time increase, parallelization approach, caching strategy, and deterministic execution rules (e.g., fixed clock injection for TTL vectors). If needed, stage vectors (P0 subset required to pass; remainder behind a nightly job) with a deadline to make all blocking."
    },
    {
      "location": "FR-10 (Import guard extension) vs FR-2/FR-3 (barrel-as-single-import-point) and ADR-001 constraints",
      "issue": "The PRD simultaneously reinforces ‘barrel as single import point’ (G-5) while allowing direct imports from @0xhoneyjar/loa-hounfour/commons and even allowing Enforcement SDK functions from both places.",
      "why_blocking": "This is a governance/architecture contradiction that will cause drift: some call sites will bypass the barrel, leading to missing re-exports, inconsistent symbol resolution, and future upgrade pain (exactly the failure mode the barrel pattern is meant to prevent). It also weakens the import-guard’s ability to enforce protocol boundaries.",
      "fix": "Pick one rule and enforce it: either (A) require all hounfour imports (including /commons) to go through @arrakis/core/protocol, and only allow the barrel to import subpaths; or (B) explicitly allow /commons direct imports and update G-5 to reflect that the barrel is not the single import point. Do not allow both for the same symbols."
    },
    {
      "location": "FR-5 (GovernedCredits + evaluateGovernanceMutation) and NFR-1 claim: “GovernanceMutation is NOT constructed in freeside (actor_id safe)”",
      "issue": "FR-5 requires wiring evaluateGovernanceMutation as an authorization gate for credit mutations, which necessarily implies constructing/handling GovernanceMutation inputs (including actor_id). This contradicts the NFR-1 analysis premise.",
      "why_blocking": "If the team follows NFR-1’s assumption, they may not implement the required mutation construction paths correctly (or miss required fields), leading to runtime rejection of mutations or incorrect authorization behavior—core billing invariants failing is a launch-blocker.",
      "fix": "Update the breaking-change analysis: acknowledge that freeside WILL construct GovernanceMutation as part of FR-5, and define the exact mutation shape(s) used for credits, including actor_id sourcing, and tests proving both acceptance and rejection paths."
    },
    {
      "location": "FR-6 (hash chain) design note: domain tag format and canonicalization",
      "issue": "The PRD specifies a domain tag format and hashing formula, but it does not require RFC 8785 JCS canonicalization (or equivalent) nor does it define what fields are included/excluded in ‘content_fields’ for hashing.",
      "why_blocking": "Audit-trail integrity is extremely sensitive to canonicalization and field selection. If different services hash slightly different JSON (key order, number formatting, omitted undefineds), integrity verification will fail and quarantine will trigger incorrectly—effectively bricking audit trails.",
      "fix": "Make canonicalization and field selection explicit and testable: require JCS canonicalization (or explicitly require using the library helper end-to-end with no reimplementation), define the hashed payload schema (exact fields), and add conformance vectors/tests that cover canonicalization edge cases."
    },
    {
      "location": "Completeness requirement (Review Focus #1) vs PRD content: v8.0.0–v8.2.0 coverage",
      "issue": "The PRD asserts completeness based on release notes/MIGRATION/ADRs, but it does not enumerate all v8.x changes in a checklist that can be verified against the actual consumed symbol set and contract.json.",
      "why_blocking": "If any consumed symbol or required schema change is missed (common in union expansions, new modules, or barrel re-export gaps), you can ship an ‘upgraded’ dependency while silently not adopting required primitives—leading to drift, runtime negotiation mismatches, or missing types at compile time.",
      "fix": "Add a blocking ‘v8.x delta checklist’ section generated from: (1) diff of exported symbols between v7.11.0 and v8.2.0 for the subpaths you consume, (2) diff of contract.json consumed symbols, and (3) a grep-based inventory of imports. Require sign-off that every new/changed consumed symbol is either adopted or explicitly deferred with rationale."
    }
  ],
  "question": "",
  "iteration": 1
}
