{
  "verdict": "CHANGES_REQUIRED",
  "summary": "The three pillars sequence logically, but several core assumptions (auth model, “public API” vs tenant/community model, billing/pricing mechanics, and self-serve onboarding) are internally inconsistent or undefined in ways that will cause you to ship the wrong platform or be unable to onboard/paywall external developers.",
  "blocking_issues": [
    {
      "location": "Pillar 1: API Surface (Deployed Today) + Twilio analogy mapping (Community ID + JWT ES256) + Gap 4/5 (API key self-service, signup)",
      "issue": "Authentication model is contradictory: endpoints are described as JWT-authenticated with JWKS, but the GTM plan repeatedly frames external developer access as “API keys” (gaib login → API key flow, API key self-service, signup → get API key). It’s unclear whether the product is JWT-first (OIDC-style) or API-key-first (Twilio/Stripe-style), and how keys relate to JWTs/JWKS.",
      "why_blocking": "If you build SDK/CLI/docs around the wrong auth primitive, external onboarding will fail (developers can’t authenticate), and you’ll likely need to rework gateway middleware, key management, docs, and portal flows. This also impacts rate limiting, tenant scoping, and BYOK separation because identity is the join key for all of them.",
      "fix": "Pick and specify one canonical external auth scheme and map the other as an implementation detail. Example: (A) API key is primary; gateway issues short-lived JWTs derived from API key (or uses HMAC key directly) and JWKS is only for first-party tokens; or (B) OAuth/OIDC is primary; API keys are optional “personal access tokens” minted via portal. Define: token format, rotation/revocation, scopes, tenant/community binding, and how gaib/SDK obtain and refresh credentials."
    },
    {
      "location": "Pillar 1 / Pillar 3: Multi-tenancy described as “per-community” + Phase 1 Managed Platform “External developers sign up, get API keys” + Gap 5 `POST /api/v1/communities`",
      "issue": "Core account model is undefined/ambiguous: is the primary customer entity a “community” (Discord/TG server), a “developer account/project,” or an “NFT collection”? The plan mixes these interchangeably (community budgets, community ID in JWT, developer signup, programmatic community creation).",
      "why_blocking": "Without a clear tenancy hierarchy, you can’t design self-serve onboarding, billing, budgets, rate limits, or dashboard UX. You risk shipping a portal that creates the wrong objects (e.g., forcing every developer to create a “community” even if they’re building a dApp), breaking isolation assumptions and making pricing impossible to explain.",
      "fix": "Define a canonical hierarchy and IDs: e.g., Account (billing owner) → Project (API keys, environments) → Tenant/Community (optional, for Discord/TG integrations) → End-user (wallet/userId). Update endpoints and docs accordingly (e.g., `POST /api/v1/projects`, `POST /api/v1/projects/{id}/api-keys`, optional `POST /api/v1/communities` only for chat integrations). Ensure budgets/rate limits attach to the billing owner (account/project) with optional sub-budgets per community/channel."
    },
    {
      "location": "Pillar 3 Pricing Model (included monthly budget + usage beyond included) + Pillar 1 billing endpoints (`/api/billing/topup` USDC x402, Paddle flag, NOWPayments flag) + “budget atomicity”",
      "issue": "Billing system requirements conflict and are underspecified: the plan proposes subscription tiers with included credits plus overage usage-based billing, but the implementation references prepaid top-ups (USDC x402), a Paddle subscription flag, and NOWPayments—without defining the source of truth ledger, how negative balances/overages work, or how invoices are generated/collected.",
      "why_blocking": "You can’t launch a paid self-serve platform without a coherent billing primitive. Prepaid credit systems and postpaid overage systems have different failure modes (hard cutoff vs invoicing), different UX, and different compliance/tax implications. If you ship with the wrong assumption, you’ll either leak cost (no enforcement) or block paying users (no way to settle overages).",
      "fix": "Choose one billing primitive for MVP and specify it end-to-end: (1) Prepaid credits only (top-up required; hard stop at $0; optional auto-top-up) OR (2) Subscription + metered overage (Stripe/Paddle metered billing; soft limits; invoicing). Define: ledger source of truth, enforcement point (gateway), reconciliation, refunds/chargebacks, crypto payment support timeline, and how “included budget” is represented (monthly credit grant vs discounted rate)."
    },
    {
      "location": "Pillar 2 Success Criteria: “dixie team builds dNFT product using only the public API (no internal shortcuts)” vs Sequencing Phase 1/2 and listed Phase 1 deliverables",
      "issue": "Dogfooding success criterion depends on platform components that are not guaranteed to exist before Pillar 2 starts: specifically, “public API” implies stable auth, key provisioning, docs/SDK/CLI, and a developer portal. But Phase 2 is positioned as validation that feeds back into Phase 1, creating a loop where Pillar 2 may start before the minimum “public-ness” exists.",
      "why_blocking": "If Pillar 2 proceeds on internal credentials/config/admin routes, you’ll get false confidence and won’t surface the real external DX failures (auth provisioning, environment setup, error semantics, quota/budget UX). Conversely, if you wait for the full portal, you may delay dogfooding unnecessarily.",
      "fix": "Define a strict “Public API MVP” gate that must be complete before Pillar 2 begins, and keep it minimal: stable auth + key provisioning flow, one quickstart, SDK/CLI for invoke/stream, and a minimal usage/budget view. Then run Pillar 2 exclusively through those surfaces. Make the feedback loop Phase 2 → Phase 1.1 (iteration), not Phase 2 → Phase 1 (foundation)."
    },
    {
      "location": "Pillar 1: “API Surface (Deployed Today)” + Gap 1 OpenAPI generation from Zod in `themes/sietch/src/api/routes/` + Appendix A multi-repo architecture (arrakis vs loa-finn) + “wire contracts via NATS schemas”",
      "issue": "The plan assumes Zod schemas are the authoritative API contract for OpenAPI generation, but the system is described as multi-repo with cross-language components (Rust gateway, TS workers) and NATS schemas as neutral wire contracts. It’s unclear which contract is canonical for external developers: REST OpenAPI, NATS schemas, or core port interfaces.",
      "why_blocking": "If you generate OpenAPI from a non-canonical layer, the published spec can drift from actual runtime behavior (especially across repos/languages), causing SDK breakage and support burden. This is a common platform failure mode: “docs compile” but clients fail in production.",
      "fix": "Declare a single source of truth for external contracts and enforce it in CI. Options: (A) REST is canonical → OpenAPI is source-controlled and tests validate gateway conformance; Zod is generated from OpenAPI (or validated against it). (B) Zod is canonical → add conformance tests that run against deployed gateway and fail on drift; version the spec and SDK together. Clarify how NATS schemas relate (internal only vs public eventing)."
    },
    {
      "location": "Pillar 3 Phase 1: “Free tier… Paid tiers… Usage-based billing… 99.9% SLA” + Pillar 1 capabilities list (rate limiting, circuit breaking) + Missing operational requirements",
      "issue": "You commit to a 99.9% SLA without defining the operational controls required for a multi-model inference platform: provider failover policy, incident response, status page, SLO measurement, and what counts as “uptime” (gateway vs model providers).",
      "why_blocking": "SLA language drives enterprise expectations and legal exposure. Without explicit SLO definitions and measurement, you can’t credibly sell/renew paid tiers, and you may be forced into expensive retrofits (multi-region, provider redundancy, observability) after customers depend on it.",
      "fix": "Either remove SLA from P1 or define it precisely: SLO target, measurement window, excluded dependencies (or include provider uptime with fallback), credits policy, and required observability (request success rate, latency, provider error budgets). Gate SLA behind P1 operational deliverables (status page + SLO dashboards + oncall)."
    },
    {
      "location": "Pillar 1 Capabilities: “BYOK key never seen by infra, deny-by-default redaction” + Pillar 3: “Usage-based billing per token already tracked” + Pricing tiers include BYOK only for Enterprise",
      "issue": "BYOK and metering are in tension but not resolved: if the platform truly never sees the key and is proxying, you still need to see prompts/tokens to meter usage and enforce budgets—unless you rely on provider-side usage reports. The plan claims per-token metering is already tracked, but doesn’t specify how that works under BYOK across providers.",
      "why_blocking": "If BYOK customers can’t be metered/enforced correctly, you either can’t charge them, can’t enforce budgets, or you violate the “key never seen / redaction” promise. This is a trust-killer for BYOK buyers and a revenue risk for you.",
      "fix": "Specify BYOK operating modes: (1) Proxy mode with full metering (you see token counts, possibly redacted content) and explicit data handling; (2) Pass-through mode with provider usage reconciliation (delayed metering) and different budget semantics. Document what is logged, what is redacted, and how costs are computed per provider."
    }
  ],
  "question": "",
  "iteration": 1
}
