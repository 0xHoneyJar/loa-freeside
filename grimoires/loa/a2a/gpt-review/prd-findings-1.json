{
  "verdict": "CHANGES_REQUIRED",
  "summary": "This PRD is close, but it contains a few domain/DB-migration contradictions that could either fail in production (migrations) or fail to actually enforce the intended invariants (timestamps and deposit amounts).",
  "blocking_issues": [
    {
      "location": "FR-2 / NFR: “Migration is additive (no destructive DDL)” + “Migration 057 uses CHECK (amount_micro >= 0)”",
      "issue": "You cannot change an existing SQLite CHECK constraint in-place without a table rebuild (SQLite doesn’t support ALTER TABLE to modify CHECK constraints).",
      "why_blocking": "If migration 057 already exists/applied in any environment, the proposed fix is not implementable as written. Attempting to “change” the constraint will either be impossible or will require destructive DDL (table recreation), directly contradicting the NFR and risking broken deploys or inconsistent schemas across environments.",
      "fix": "Clarify the migration strategy: (A) if 057 is not merged/applied anywhere, amend 057 before merge; or (B) if 057 may already be applied, add a new migration (e.g., 058) that rebuilds `tba_deposits` safely (create new table with desired CHECK, copy data, drop old, rename) and explicitly waive the “no destructive DDL” constraint for this table rebuild (or redefine NFR to allow rebuild-with-copy as non-destructive)."
    },
    {
      "location": "FR-2: “Change constraint to CHECK (amount_micro >= 0)… Terminal states (completed) still require amount_micro > 0 (enforced at application level)”",
      "issue": "The PRD’s stated requirement is internally inconsistent with the earlier “Critical requirements: … SQLite-backed authoritative ledger, conservation invariants” posture: it moves a core integrity rule (non-zero amount for completed deposits) out of the DB and into application logic without specifying enforcement points or reconciliation coverage.",
      "why_blocking": "If any code path (now or future) writes `completed` with `amount_micro = 0`, the DB will accept it and you will have an irreconcilable “completed deposit with zero value” record that can break accounting, downstream settlement assumptions, and reconciliation invariants. This is exactly the class of bug DB constraints are meant to prevent in a financial ledger context.",
      "fix": "Make the rule enforceable at the DB layer or explicitly define invariant enforcement elsewhere. Options: (1) Add a DB CHECK that encodes state-dependent constraint, e.g. `CHECK ((status IN ('detected','confirming','confirmed','bridging','failed') AND amount_micro >= 0) OR (status = 'completed' AND amount_micro > 0))` (adjust statuses to your exact enum). (2) If status is not stored or is stored elsewhere, add a trigger that rejects invalid transitions to `completed` when `amount_micro = 0`. If you truly must keep it app-level, add a reconciliation check that fails hard when `status='completed' AND amount_micro<=0` and specify exactly where the write is validated."
    },
    {
      "location": "FR-3: Recipient Ledger Entry Type (Moderate) + “Credit ledger: EntryType union controls allowed ledger entry types via CHECK constraint”",
      "issue": "Adding `'transfer_in'` to the EntryType union and DB CHECK is described, but the PRD doesn’t ensure end-to-end semantic consistency between `entry_type`, `source_type`, and reconciliation logic—specifically whether `entry_type` is intended to represent accounting semantics (deposit/transfer) or ingestion source (bridge/transfer).",
      "why_blocking": "If `entry_type` is used for accounting classification in other parts of the system (reporting, balance computation, fee logic), reclassifying recipient credits from `'deposit'` to `'transfer_in'` can silently change behavior outside reconciliation. That can cause incorrect balances, misreported revenue, or broken invariants—i.e., building the wrong thing while “fixing” Check 5.",
      "fix": "Add an explicit requirement that balance computation and any aggregation logic treats `'transfer_in'` as a credit-increasing entry equivalent to the previous recipient `'deposit'` behavior. Concretely: identify the balance query/function and require tests proving balances are unchanged for recipient accounts after the type change. If `entry_type` is meant to be a small stable set, consider keeping `entry_type='deposit'` and instead fix reconciliation to key off `source_type` (or add a separate `transfer_direction` field)."
    },
    {
      "location": "FR-4: SqliteTimestamp branded type + Acceptance: “All timestamp comparison sites type-check against SqliteTimestamp”",
      "issue": "Branding `string` does not, by itself, prevent `.toISOString()` from being used unless all relevant APIs are typed to require `SqliteTimestamp` and you eliminate/guard casts; the PRD doesn’t specify the enforcement boundary (DB row types, query result typing, insert/update parameter typing).",
      "why_blocking": "If only `sqliteTimestamp()` returns a branded type but DB access layers still accept `string`, developers can keep passing ISO strings and the compiler won’t stop them. That means the PRD’s core goal (“compile-time prevention”) may not actually be achieved, leading to recurring timestamp bugs and incorrect ordering/comparisons in SQLite (especially if mixed formats slip in).",
      "fix": "Define the exact typed surfaces that must use `SqliteTimestamp`: (1) insert/update parameter types for any `*_at` columns, (2) row model types returned from SQLite for those columns, and (3) comparison helpers. Add an acceptance test at the type level (tsd or a `// @ts-expect-error` compile test) demonstrating that passing `new Date().toISOString()` to a function expecting `SqliteTimestamp` fails compilation."
    }
  ],
  "question": "",
  "iteration": 1
}
