{
  "verdict": "CHANGES_REQUIRED",
  "summary": "This plan is close, but it has a few missing/incorrectly-specified tasks and dependency gaps that can prevent a successful, CI-green schema-only adoption.",
  "blocking_issues": [
    {
      "location": "Sprint 1 / Task 1.1 (Version Pin Migration) + Success Criteria #1",
      "issue": "Acceptance criteria requires an “immutable semver reference” while Task 1.1 explicitly allows npm semver, git tag, or SHA; npm semver ranges are not immutable and can violate the supply-chain trust boundary intent.",
      "why_blocking": "If the team chooses an npm semver/range (even if it resolves today), the sprint can fail review/verification against SDD §3.5.3 trust boundary expectations and can also make DIST_HASH non-reproducible across installs, breaking later contract/bundle verification confidence.",
      "fix": "Make the pin requirement explicit and testable: require either (a) exact version (no ^/~) plus lockfile integrity, or (b) git commit SHA. Add AC: “dependency spec is exact (no range) and lockfile updated; reinstall reproduces same DIST_HASH.” Update Success Criteria #1 to match."
    },
    {
      "location": "Sprint 1 / Task 1.4 (Hash Chain + Evaluation Geometry Re-exports)",
      "issue": "Task 1.4 includes re-exporting `NativeEnforcement` but Task 1.2’s export verification list does not include `NativeEnforcement` (or its actual entrypoint), so 1.4 can be blocked by missing/unknown symbol location.",
      "why_blocking": "SDD §3.1.1 makes runtime export verification mandatory before adding to the barrel/contract. As written, 1.4 may attempt to export a symbol that wasn’t verified, causing implementation churn or CI failures if the symbol isn’t present at runtime or is type-only.",
      "fix": "Add `NativeEnforcement` (and any other 1.4 symbols) to Task 1.2’s verification checklist with explicit entrypoints. Alternatively, change 1.4 dependency to: “depends on 1.2 verifying `NativeEnforcement` export surface” and add a fallback rule if it is type-only."
    },
    {
      "location": "Sprint 2 / Task 2.2 (Bundle Hash Recomputation) dependencies",
      "issue": "Task 2.2 updates `contract.json` fields (`bundle_hash`, `vector_count`) but does not depend on Task 2.1, which also edits `contract.json` (entrypoints + provider_version_range).",
      "why_blocking": "Two independent edits to the same file in the same sprint without an explicit ordering is a common source of merge conflicts and accidental overwrites (e.g., recomputing hash on an outdated contract.json or losing entrypoint updates), which can break contract validation and CI.",
      "fix": "Add an explicit dependency: Task 2.2 depends on Task 2.1 (or combine them into a single “contract.json update + hash recompute” task with one set of acceptance criteria). Also add AC: “validate.mjs passes after both changes in one final contract.json state.”"
    },
    {
      "location": "Sprint 2 / Task 2.4 (ADR-001 Import Guard Tests) acceptance criteria",
      "issue": "Layer 1 identity check is specified as “`TaskTypeSchema` barrel identity = routing-policy variant,” but the plan does not define how identity is asserted (reference equality vs deep equality) nor does it ensure both symbols are runtime values (schemas are runtime, types are not).",
      "why_blocking": "Without a concrete, testable method, the team can implement a non-working identity assertion (e.g., comparing types, or comparing two separately-imported schema instances that are structurally equal but not referentially equal due to module duplication). This can cause flaky or failing CI and block the sprint’s core guardrail (SDD §4.2).",
      "fix": "Specify the exact assertion and import paths to avoid type identity drift: e.g., `expect(TaskTypeSchema).toBe(RoutingTaskTypeSchema)` (reference equality) and ensure both are imported from the exact intended modules. Add a precondition task/AC to detect duplicate module instances (e.g., ensure only one resolved copy of loa-hounfour in pnpm lock / node_modules)."
    },
    {
      "location": "Sprint 1 / Task 1.3 (Protocol Barrel Governance Re-exports) vs PRD/SDD constraint",
      "issue": "AC-1.1 says “All verified governance types imported in protocol barrel,” but Task 1.2’s list includes several items that may be runtime-only, type-only, or belong in non-barrel surfaces; the plan doesn’t constrain “what must be barrel-exported” vs “what must only be contract-listed,” risking violation of NFR-2 (schema-only) and AC-3.1 (ONLY aliased Governance* variants).",
      "why_blocking": "If the team barrel-exports non-governance names, or exports governance symbols without the required aliasing discipline, you can get naming collisions / type identity drift / routing contamination—exactly what ADR-001 is meant to prevent—leading to failing conformance tests or review rejection.",
      "fix": "Add an explicit mapping table as an acceptance artifact for 1.3: for each verified symbol, mark {barrel-exported as Governance*, contract-only, internal-only}. Add AC: “No non-aliased governance symbol names are exported from protocol/index.ts; governance subpath exports are not re-exported under their original names.”"
    }
  ],
  "question": "",
  "iteration": 1
}
