{
  "verdict": "CHANGES_REQUIRED",
  "summary": "As written, this plan is likely to fail in production because it removes v4.6.0/JWT compatibility without a concrete dual-accept + rollout window, and it introduces a canonical NftId format without a required DB/backfill + read-compat plan.",
  "blocking_issues": [
    {
      "location": "Sprint 2 — Task 2.1 (Adopt AgentIdentity / remove v4.6.0 claims) + Sprint 2 — Task 2.7 (Remove v4.6.0 backward compatibility code)",
      "issue": "Plan removes v4.6.0 JWT claim normalization and the PROTOCOL_V7_NORMALIZATION flag, but does not include a dual-accept window, token TTL strategy, or coordinated rollout steps across all token issuers/consumers.",
      "why_blocking": "If any existing sessions/tokens (Discord worker, web, API clients, or loa-finn) still present v4.6.0-style claims (e.g., trust_level integer or missing trust_scopes), Freeside will start rejecting them immediately after deploy. That is a hard auth outage and will force rollback; with 1 engineer, diagnosing cross-surface auth breakage is a common sprint-killer.",
      "fix": "Add explicit tasks/AC for a staged JWT migration: (1) keep normalizeInboundClaims dual-accept for a bounded window (e.g., accept v6/v7 claims; optionally accept v4.6.0 only if still observed), (2) add metrics/logging for claim versions seen, (3) define a cutoff date tied to max JWT TTL + session TTL, (4) only remove v4.6.0 branch after telemetry shows 0 usage for N days, and (5) add integration tests covering both claim shapes during the window."
    },
    {
      "location": "Sprint 2 — Task 2.3 (Adopt canonical NftId format)",
      "issue": "NftId format change is specified for new records and JWT claims, but there is no concrete migration/backfill task, no read-compat strategy, and no acceptance criteria ensuring existing records/queries continue to work.",
      "why_blocking": "Changing identifiers from ad-hoc formats to eip155 canonical will break lookups, joins, caches, and any persisted references unless the system can read both formats or the DB is backfilled. The plan explicitly updates queries (my-agent-data.ts) and JWT claim emission, which can immediately desynchronize stored data vs. incoming identifiers—causing user-facing failures (missing agents/threads) and forcing rollback.",
      "fix": "Add a required migration task: (1) inventory all storage locations/columns where nftId is persisted and indexed, (2) implement dual-read (accept old + new) and single-write (write canonical) for a window, (3) add a backfill script with idempotency + progress logging, (4) add DB constraints/index updates if needed, (5) add integration tests proving old-format records remain accessible after deploy, and (6) define collision/ambiguity handling (old formats that cannot be deterministically mapped)."
    },
    {
      "location": "Sprint 1 — Task 1.5 (Update CONTRACT_VERSION and version negotiation) + overall cross-system dependency",
      "issue": "The plan assumes loa-finn supports v7.0.0 (MIN_SUPPORTED_VERSION=6.0.0) but does not include a concrete coordination/verification task against real loa-finn deployments (staging/prod) nor a defined compatibility window policy (how long 6.x is accepted, what headers/fields are dual-parsed).",
      "why_blocking": "S2S protocol mismatches are a primary failure mode: even if TypeScript compiles, runtime wire changes (CompletionRequest/Result, StreamEvent, headers) can break inference. Without an explicit “verify peer version in environment X” gate and a dual-stack parsing plan, you can ship a build that passes unit tests but fails immediately in staging/prod.",
      "fix": "Add an explicit pre-deploy gate task: hit loa-finn staging/prod discovery (or a version endpoint) and record supported versions; add AC that staging handshake succeeds before proceeding. Also define a bounded dual-accept policy: which versions are accepted, for how long, and which fields are parsed in a backward-compatible way (headers + body)."
    },
    {
      "location": "Sprint 2 — Tasks 2.5 (StreamEvent) and 2.6 (CompletionRequest/Result)",
      "issue": "These tasks change the S2S wire types but the plan does not add end-to-end integration tests that validate real SSE event streams and completion request/response payloads against loa-finn (only mentions a stub and some unit updates).",
      "why_blocking": "SSE/event-stream parsing and request/response schema drift often fails only at runtime (ordering, optional fields, unknown event types, JSON framing). A stub that you also update to v7.0.0 can mask incompatibilities. Without a contract test that replays captured real streams (or validates against canonical JSON schema), you risk shipping a broken inference path.",
      "fix": "Add integration tests that (1) replay recorded SSE transcripts from loa-finn (6.x and 7.x if applicable) and assert parsing into StreamEvent union, (2) validate CompletionRequest serialization and CompletionResult parsing against canonical JSON schema (ajv), and (3) include an “unknown event type” forward-compat test to ensure it doesn’t crash the stream."
    },
    {
      "location": "Sprint 1 — Task numbering / dependency clarity (Sprint 1 has two 'Task 1.3' entries)",
      "issue": "Duplicate task IDs (two Task 1.3s) create ambiguous references for sequencing and review gates (1.3–1.5 referenced by 1.2).",
      "why_blocking": "This is not a formatting nit: it breaks dependency tracking (“Tasks 1.3–1.5”) and can cause the engineer/reviewer to execute the wrong step order or miss a required de-vendoring item, leading to incomplete work and failed sprint gate (build clean / no vendored copies).",
      "fix": "Renumber tasks uniquely (e.g., 1.3 state-machines, 1.4 billing-types, 1.5 guard-types, shift subsequent tasks) and update all cross-references (notably Task 1.2 and Sprint 1 gate)."
    },
    {
      "location": "Sprint 1 — Task 1.1 (Dependency bump) and overall supply-chain pinning",
      "issue": "Task text still allows 'github:...#v7.0.0 (or latest main commit)' while acceptance criteria requires immutable SHA; there is no explicit step to resolve and record the exact commit SHA for v7.0.0 and ensure pnpm lockfile cannot float.",
      "why_blocking": "If the engineer follows the implementation text and pins to a tag or main, builds can become non-reproducible and may break mid-sprint due to upstream changes—especially risky when de-vendoring depends on exact export surfaces. That can derail the entire 4-sprint migration.",
      "fix": "Make the implementation unambiguous: require resolving v7.0.0 tag → commit SHA and pin to that SHA in both package.json files; add AC that CI verifies the dependency spec is a SHA (e.g., regex check) and that lockfile contains the same resolved commit."
    }
  ],
  "question": "",
  "iteration": 1
}
