{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Plan is close, but a few missing/incorrect dependencies and migration/flag coupling issues would likely break sequencing, block deploys, or make features non-toggleable as claimed.",
  "blocking_issues": [
    {
      "location": "Sprint 1 / Task 1.2 (insertLotEntry) + Sprint 4 / Task 4.1 (event sourcing columns)",
      "issue": "insertLotEntry AC requires allocating sequence_number when FEATURE_EVENT_SOURCING is enabled, but the required schema (sequence_number column + community_event_sequences table + trigger) is only created in Sprint 4.",
      "why_blocking": "If FEATURE_EVENT_SOURCING is enabled in any environment before Sprint 4 lands (or if tests toggle it), insertLotEntry will fail at runtime (missing column/table) or cannot satisfy AC-1.2.3. This is an impossible dependency ordering as written.",
      "fix": "Either (A) move Migration 0013a (or at least the minimal columns/table needed for allocation) into Sprint 1 before Task 1.2, or (B) change Task 1.2 to explicitly NOT allocate sequences until Sprint 4 (feature flag must remain false), with an acceptance criterion that insertLotEntry degrades safely when event-sourcing schema is absent (e.g., detects column existence once at startup and disables allocation)."
    },
    {
      "location": "Sprint 2 / Task 2.3 (Integration into Debit Path) and Sprint 1 / Task 1.2",
      "issue": "Task 2.3 says debitLots() accepts purpose and “all INSERTs go through insertLotEntry()”, but Task 1.2 already requires refactoring debitLots/mint/reserve/release/expire to use insertLotEntry. The sequencing implies debitLots is refactored before purpose exists, then refactored again.",
      "why_blocking": "This creates a high chance of merge conflicts and duplicated work for a single engineer, and more importantly it risks landing an intermediate state where debitLots is refactored but purpose is not written (or vice versa), violating Sprint 2 success criteria (“Every debit operation records a purpose”).",
      "fix": "Make the dependency explicit: either (A) in Sprint 1 refactor to insertLotEntry but keep a purpose parameter plumbed through as optional (writing only when column exists/flag enabled), or (B) defer the debitLots refactor portion of Task 1.2 for debitLots specifically into Sprint 2 so the refactor and purpose plumbing happen in one change. Update ACs to avoid double-touching the same hot path."
    },
    {
      "location": "Sprint 3 / Task 3.2 (Debit Hourly Rollup Job) and Sprint 2 / Purpose column",
      "issue": "Sprint dependency graph states Velocity depends on purpose column, but Task 3.2/3.3 do not list Task 2.1 as a dependency and do not specify whether rollups are purpose-segmented or purpose-agnostic.",
      "why_blocking": "If the SDD expects velocity to be computed per purpose (or filtered by purpose), the rollup schema/job will be wrong and require rework. If velocity is purpose-agnostic, then the stated dependency on purpose is incorrect and will cause planning/implementation mismatch. Either way, ambiguity here can derail Sprint 3 implementation.",
      "fix": "Clarify in Sprint 3 tasks/ACs whether community_debit_hourly includes purpose (e.g., PK (community_id, hour, purpose)) or explicitly does not. Then align dependencies: add Task 2.1 as a dependency if purpose is required; otherwise remove the dependency from the graph and ensure the rollup query ignores purpose safely."
    },
    {
      "location": "Sprint 1 / Task 1.5 (Feature Flag Infrastructure) + Rollout Strategy section",
      "issue": "AC-1.5.3 says disabled features produce “no column writes”, but multiple tasks add columns/constraints/triggers that will exist regardless of flags (purpose column default + NOT NULL check; event sourcing trigger enforcing fields; governance tables). Also, Task 4.1 makes correlation_id NOT NULL DEFAULT, while Task 1.2 also claims to always set correlation_id.",
      "why_blocking": "This is a deploy/runtime failure risk because the plan claims flags can be independently toggled, but DB-level enforcement (defaults/triggers/checks) can force writes or reject writes even when a feature is “disabled”. That breaks the stated rollout strategy and can cause production incidents when toggling flags.",
      "fix": "Make DB enforcement explicitly compatible with flags: (A) ensure triggers/check constraints are conditional on a per-community flag stored in DB (not just app env), or (B) delay installing strict triggers/NOT NULL checks until the corresponding feature is enabled everywhere. Update AC-1.5.3 to a testable statement like: “When FEATURE_X is false, application code does not read/write X fields and endpoints are not registered; DB schema may exist.”"
    },
    {
      "location": "Sprint 5 / Task 5.4 (Outbox Worker)",
      "issue": "Outbox processing concurrency/locking semantics are not specified (e.g., SELECT ... FOR UPDATE SKIP LOCKED), and idempotency keying is underspecified beyond “policy_id version check”.",
      "why_blocking": "Without a clear locking strategy, multiple worker instances (or retries) can process the same outbox row concurrently, causing duplicate conservationGuard.updateLimit() calls and inconsistent policy enforcement. This is a classic source of production failure for outbox patterns.",
      "fix": "Add explicit ACs: worker claims rows with `FOR UPDATE SKIP LOCKED` (or an atomic UPDATE ... WHERE processed_at IS NULL RETURNING), uses a unique idempotency key (policy_id + policy_version or outbox_id) at the conservation guard boundary, and guarantees exactly-once side effects from at-least-once delivery. Include a concurrency integration test with 2 workers."
    },
    {
      "location": "Sprint 5 / Migrations numbering (Task 5.2 labeled Migration 0015) vs Sprint 3 (Task 3.1 labeled Migration 0015)",
      "issue": "Two different migrations are both numbered 0015.",
      "why_blocking": "Most migration runners will fail or behave unpredictably with duplicate version identifiers, blocking deploy and halting the sprint’s ability to ship.",
      "fix": "Renumber one migration (e.g., make admin audit log 0016) and add an acceptance criterion that the migration tool’s ordering/versioning is validated in CI (e.g., “no duplicate migration IDs”)."
    }
  ],
  "question": null,
  "iteration": 1
}
