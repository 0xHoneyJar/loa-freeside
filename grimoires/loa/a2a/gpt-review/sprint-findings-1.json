{
  "verdict": "CHANGES_REQUIRED",
  "summary": "This plan is close, but several incorrect dependencies and missing infra/security tasks (Cloud Map/JWKS URL, NATS provisioning, JWKS key lifecycle, and WebSocket/ECS wiring) will block end-to-end implementation within the cycle.",
  "blocking_issues": [
    {
      "location": "Sprint 2 — Task 2.3 S2S JWT Validation on loa-finn",
      "issue": "JWKS fetch URL points to finn instead of freeside, and the port/host are inconsistent with the trust model.",
      "why_blocking": "loa-finn cannot validate tokens if it cannot fetch JWKS; as written it will call `http://finn.../.well-known/jwks.json` which is the wrong service. This breaks Sprint 2 gate and everything downstream (payments/routing/web chat).",
      "fix": "Change acceptance criteria to fetch JWKS from freeside via internal discovery, e.g. `http://freeside.arrakis-{env}.local:3000/.well-known/jwks.json` (or whatever the freeside Cloud Map name is). Add an explicit Sprint 1 task/AC to register freeside in Cloud Map (if not already) and document the internal base URLs/ports for both services."
    },
    {
      "location": "Sprint 1 — Tasks 1.1/1.2 (Service Discovery / DNS)",
      "issue": "Cloud Map and Route53 internal DNS are conflated; the plan assumes `finn.arrakis-{env}.local` resolves but doesn’t include the required Cloud Map namespace/service wiring details.",
      "why_blocking": "If service discovery isn’t actually created/attached to the ECS service, freeside→finn calls (and later finn→freeside JWKS fetch) will fail in ECS even if Docker Compose works. This is a common production-only failure mode.",
      "fix": "In Sprint 1, add explicit acceptance criteria for: (a) Cloud Map private DNS namespace exists/selected, (b) ECS service has `service_registries` configured, (c) verify resolution from a task (exec into freeside task and `nslookup finn...`), and (d) remove/clarify the Route53 record requirement unless you truly manage a separate private hosted zone."
    },
    {
      "location": "Sprint 2 — Task 2.2 (Key rotation) + Sprint 7 — Task 7.4 (Rotation test)",
      "issue": "Key lifecycle prerequisites are missing: there is no task to initially generate/publish the public JWK into `s2s_jwks_public_keys`, nor to manage multiple keys/expiry in DB.",
      "why_blocking": "JWKS endpoint is specified as DB source-of-truth; without a concrete “bootstrap key material” step, staging cannot pass S2S auth. Rotation test also can’t run if there’s no mechanism to insert/activate keys and set `activeKid` consistently.",
      "fix": "Add a Sprint 1 or Sprint 2 task: generate ES256 keypair(s), store private key + `activeKid` in Secrets Manager, insert corresponding public JWK rows into `s2s_jwks_public_keys` with `created_at/expires_at`, and a small admin/ops script to add a new key + mark active. Update 2.1 AC to specify selection rules (e.g., serve all non-expired keys; mark one as current)."
    },
    {
      "location": "Sprint 4 — Task 4.3 Durable Usage Reporting via NATS JetStream",
      "issue": "NATS/JetStream infrastructure provisioning is not planned (no ECS service, no cluster, no creds, no network rules), yet Sprint 4 gate requires it operational.",
      "why_blocking": "You cannot make JetStream “operational” in staging without deploying NATS and configuring connectivity/secrets. This will stall budget finalization and admin usage freshness assumptions.",
      "fix": "Add an infra task (Sprint 1 or Sprint 4) to provision NATS JetStream (ECS service or managed alternative), including: security group rules, service discovery name, persistence volume strategy, auth (nkeys/user+pass), and Secrets Manager entries. Alternatively, change Sprint 4 to use DB-outbox/SQS as the durable channel and defer JetStream to a later cycle (but then update gates/FR mapping accordingly)."
    },
    {
      "location": "Sprint 4 — Tasks 4.1/4.2/4.3 (Budget lifecycle)",
      "issue": "Critical dependency mismatch: 4.2 requires token usage (`X-Token-Count` or usage event) but Sprint 2’s E2E inference does not require finn to emit token counts/usage in a reliable way.",
      "why_blocking": "If finn doesn’t deterministically provide token usage, you can’t finalize budgets correctly; this cascades into admin usage, conservation guard, and load test acceptance criteria.",
      "fix": "Add/strengthen Sprint 2 Task 2.4 acceptance criteria to require finn emits `X-Token-Count` (or SSE done event usage) and that freeside records it. Then Sprint 4 can build reservation/finalization on a known contract."
    },
    {
      "location": "Sprint 6 — Task 6.5 Web Chat Widget (WebSocket) + Sprint 1/2 infra",
      "issue": "WebSocket production wiring is missing: ALB listener rules/timeouts, target group protocol settings, and ECS deployment drain behavior aren’t captured as tasks.",
      "why_blocking": "A WebSocket feature can work locally but fail in ECS/ALB due to idle timeout defaults, missing stickiness expectations, or incorrect health checks. Your AC mentions lifecycle constraints but not the infra changes needed to enforce them.",
      "fix": "Add a task (Sprint 1 or Sprint 6) for ALB/WebSocket configuration: ALB idle timeout set to ≥300s, target group health check path, deregistration delay aligned with 120s drain, ECS deployment configuration (min/max healthy percent) for graceful drain, and an explicit staging verification (open WS, deploy, confirm drain behavior)."
    },
    {
      "location": "Sprint 3 — Task 3.7 Webhook Rate Limiting + DoS Protection",
      "issue": "WAF throttling “per payment_id” is specified but no concrete mechanism is planned to extract `payment_id` into a WAF key (NOWPayments sends JSON body; WAF typically keys on IP/headers/query/cookies).",
      "why_blocking": "If implemented as written, this task may be impossible on ALB/WAF without redesign (e.g., putting payment_id in path/query/header). It risks stalling Sprint 3 gate late in the cycle.",
      "fix": "Revise AC to an implementable control: (a) IP-based rate limit at WAF, plus (b) application-level idempotency + per-payment DB lock already in 3.2, and optionally (c) require NOWPayments to include `payment_id` in a header/query you can rate-limit on. If you keep per-payment throttling, add a task to change webhook URL format to `/api/crypto/webhook/:paymentId` (or require a header) and validate NOWPayments supports it."
    },
    {
      "location": "Sprint 2 — Task 2.5 PgBouncer Read-Only Role for loa-finn",
      "issue": "PgBouncer is treated as configurable but there is no infra task to deploy/manage PgBouncer in ECS or confirm you control its config in this environment.",
      "why_blocking": "If PgBouncer isn’t already part of the existing AWS stack (or is managed elsewhere), this task can’t be completed and may block finn connectivity assumptions (and load baseline).",
      "fix": "Add a prerequisite validation task in Sprint 1: confirm PgBouncer exists and is configurable (where config lives, how it’s deployed). If it doesn’t exist, add an infra task to provision it (or drop PgBouncer from this cycle and connect finn directly with a DB role + RDS Proxy)."
    }
  ],
  "question": "",
  "iteration": 1
}
