{
  "verdict": "CHANGES_REQUIRED",
  "summary": "The plan is close, but a few tasks/criteria are internally inconsistent or missing critical implementation details that would likely block the upgrade or make it non-reproducible at runtime/CI.",
  "blocking_issues": [
    {
      "location": "Sprint 1 / Task 1.1 (AC-1.1.4) and overall sequencing",
      "issue": "AC allows “temporary any stubs” to make tsc pass immediately after the pin bump, but there is no explicit follow-up task to remove those stubs before later sprints rely on type correctness (barrel/type reduction/boundary hardening).",
      "why_blocking": "If the pin bump is made to compile via stubs, later work can silently build on incorrect types and then fail during reduction/migration (or worse: pass CI but regress runtime behavior). This is a classic sprint-failure mode in protocol upgrades because the “temporary” workaround becomes the de facto baseline.",
      "fix": "Either (a) remove the allowance and require real fixes in Sprint 1, or (b) add an explicit tracked task (e.g., Sprint 2 Task 2.x) with AC: “all temporary any stubs removed; diff list empty; tsc passes without stubs” and gate Sprint 3+ on it."
    },
    {
      "location": "Sprint 1 / Task 1.2 (AC-1.2.3, AC-1.2.5, AC-1.2.8) — supply-chain verification",
      "issue": "The rebuild/verification approach is not fully artifact-bound/deterministic as written: `npm ci --ignore-scripts` may prevent the library build from producing `dist`, and the DIST_HASH recipe is vulnerable to non-determinism (file metadata, line endings, build timestamps) without explicit SOURCE_DATE_EPOCH / deterministic build settings.",
      "why_blocking": "This can cause the sprint to fail in CI because you won’t be able to reproduce the expected DIST_HASH across machines/runs, or you won’t be able to build dist at all if build steps rely on lifecycle scripts. That directly violates the critical requirement: “artifact-bound verification” and reproducible builds.",
      "fix": "Clarify the build pipeline: fetch+checkout SHA, install deps in a way that still allows building (e.g., `npm ci` then explicitly run the build command with scripts allowed, or use `pnpm --ignore-scripts` only for the *consumer* install but not for the isolated build). Add explicit determinism controls in AC: set `SOURCE_DATE_EPOCH`, ensure build does not embed timestamps, and compute DIST_HASH from a canonical tarball (e.g., `npm pack` output) or from normalized file contents (fixed ordering + fixed newlines) with documented exclusions."
    },
    {
      "location": "Sprint 1 / Task 1.2 (AC-1.2.6) and Sprint 2 / Task 2.1 vs exports map reality",
      "issue": "The plan hard-codes “All 7 export specifiers resolve” and later enumerates ~60 symbols to re-export, but there is no task to confirm the actual `@0xhoneyjar/loa-hounfour` v7.9.2 `package.json#exports` map shape (ESM/CJS, types entrypoints, conditional exports) and align Node/TS resolution accordingly.",
      "why_blocking": "If the exports map differs (missing subpaths, different conditions, or types-only paths), you can end up with TS compiling while Node runtime fails (or tests fail depending on runner). This is a frequent hard blocker during upgrades with subpath exports.",
      "fix": "Add an explicit “exports map audit” task before barrel expansion (or fold into Task 2.1 with concrete AC): record the exact exports map for v7.9.2, confirm which conditions are used in your runtime (node/jest/vitest/ts-node), and update tooling config if needed (e.g., `moduleResolution: nodenext`, jest ESM handling). Gate Task 2.1 on that audit."
    },
    {
      "location": "Sprint 2 / Task 2.1 (AC-2.1.8) — barrel scope contradiction",
      "issue": "AC-2.1.8 says “Only symbols consumed by arrakis code are re-exported,” but the task description says “re-export ~60 new canonical symbols,” and the AC list enumerates many symbols that may not be consumed.",
      "why_blocking": "This is not just wording: it creates an untestable/contradictory completion condition. The engineer can’t satisfy both if arrakis doesn’t currently consume many of the listed exports. That ambiguity can stall the sprint at review time.",
      "fix": "Pick one measurable rule: either (a) “export exactly the allowlisted set in SDD §3.3 (the ~60 symbols)” or (b) “export only what is referenced in repo (automated by a script that derives used symbols).” Update AC accordingly and add a simple verification method (script/grep output committed)."
    },
    {
      "location": "Sprint 4 / Task 4.2 (PagerDuty + dashboard) and Sprint 4 overall success criteria",
      "issue": "PagerDuty alerting and dashboard work is included, but there is no explicit task to wire metrics to the actual metrics backend used in arrakis (namespacing, registry, test environment), nor acceptance criteria that can be validated in CI (PagerDuty config typically can’t be proven from unit tests alone).",
      "why_blocking": "This can block sprint completion because the AC requires external system configuration (“PagerDuty alert configured”, “Dashboard panel”) that a single engineer may not be able to validate/merge purely via code, and CI cannot assert it reliably. It risks ending Sprint 4 with “done in code” but failing acceptance.",
      "fix": "Split into (1) code-level instrumentation with CI-verifiable AC (counter registration + emission + snapshot/unit tests), and (2) ops/config task with a concrete, repo-based artifact (e.g., Terraform/JSON dashboard + alert rule definitions) that can be code-reviewed and tested (lint/plan). If ops config is out-of-repo, change AC to “PR created in ops repo and linked” and make that dependency explicit."
    },
    {
      "location": "Sprint 4 / Task 4.6 (AC-4.6.1) — kill-switch verification",
      "issue": "AC-4.6.1 says “verify all boundary entry points use BigInt() directly” in legacy mode, but the design introduces a wrapper (`parseBoundaryMicroUsd`) that will still be called; it would internally choose legacy parsing. The AC as written is likely impossible once migrations are done.",
      "why_blocking": "This is a concrete acceptance mismatch that will fail review/testing: after migration, entry points should call the wrapper, not BigInt directly. You can’t satisfy “all entry points use BigInt directly” without undoing the migration.",
      "fix": "Rewrite AC-4.6.1 to: “In legacy mode, wrapper returns legacy BigInt parse result and does not reject inputs that legacy accepts; canonical parser is not invoked (or is invoked but ignored) per design.” Add an assertion via spies/counters: canonical parse call count is 0 in legacy mode (if that’s required) or canonical result is never used."
    },
    {
      "location": "FR sequencing / dependency graph vs tasks (FR-6 → FR-5 ordering)",
      "issue": "The stated phased dependency order is FR-1→FR-2→FR-3→FR-4→FR-6→FR-5, but the FR dependency graph also shows FR-7 and FR-8 branching off FR-2/FR-3. The plan schedules FR-7/FR-8 in Sprint 2 (good), but there is no explicit gating that FR-7 conformance + golden baseline replay must be green before starting boundary enforcement work in Sprint 4.",
      "why_blocking": "Boundary hardening (FR-6) without a green compatibility baseline/conformance suite increases the chance of runtime regressions and makes it hard to distinguish “parser hardening intended change” from “upgrade regression.” This can cause Sprint 4 to stall in debugging without a trusted baseline.",
      "fix": "Add an explicit dependency/gate: Sprint 4 cannot start until Sprint 2 conformance (202 vectors) + Sprint 1 golden replay are green in CI. Make it a Sprint 3 or Sprint 4 entry criterion."
    }
  ],
  "question": "",
  "iteration": 1
}
