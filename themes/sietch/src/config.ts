import { z } from 'zod';
import { config as dotenvConfig } from 'dotenv';
import type { Address } from 'viem';
import { logger } from './utils/logger.js';
import {
  AdminApiKeyService,
  type AdminApiKeyRecord,
} from './services/security/AdminApiKeyService.js';

// Load environment variables from .env.local for development
dotenvConfig({ path: '.env.local' });
dotenvConfig(); // Fallback to .env

/**
 * Zod schema for parsing string booleans from environment variables
 * Properly handles "true"/"false" strings unlike z.coerce.boolean()
 * which incorrectly coerces "false" to true (any non-empty string is truthy)
 */
const envBooleanSchema = z
  .union([z.boolean(), z.string()])
  .transform((val) => {
    if (typeof val === 'boolean') return val;
    const lower = val.toLowerCase().trim();
    return lower === 'true' || lower === '1' || lower === 'yes';
  });

/**
 * Zod schema for validating Ethereum addresses
 */
const addressSchema = z.string().regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address');

/**
 * Zod schema for validating comma-separated address lists
 */
const addressListSchema = z
  .string()
  .transform((val) => val.split(',').map((addr) => addr.trim()).filter(Boolean))
  .pipe(z.array(addressSchema));

/**
 * Zod schema for validating comma-separated URL lists
 */
const urlListSchema = z
  .string()
  .transform((val) => val.split(',').map((url) => url.trim()).filter(Boolean))
  .pipe(z.array(z.string().url()));

/**
 * Admin API key schema: "key:name,key:name" or "bcrypt_hash:name,bcrypt_hash:name"
 *
 * Sprint 73 (HIGH-1): Supports both plaintext (legacy) and bcrypt-hashed keys.
 * New deployments should use bcrypt hashes generated by:
 *   npx tsx scripts/generate-api-key.ts
 *
 * The parser detects the format:
 * - Plaintext: Stored in legacyKeys Map for backward compatibility
 * - Bcrypt ($2b$...): Stored in hashedKeys array for secure validation
 */
const adminApiKeysSchema = z
  .string()
  .transform((val) => {
    const legacyKeys = new Map<string, string>();
    const hashedKeys: AdminApiKeyRecord[] = [];

    if (!val) {
      return { legacyKeys, hashedKeys };
    }

    for (const pair of val.split(',')) {
      // Use lastIndexOf to handle bcrypt hashes which contain $
      const colonIndex = pair.lastIndexOf(':');
      if (colonIndex === -1) continue;

      const keyOrHash = pair.substring(0, colonIndex).trim();
      const name = pair.substring(colonIndex + 1).trim();

      if (!keyOrHash || !name) continue;

      // Detect bcrypt hash format: $2a$, $2b$, or $2y$ prefix
      const isBcryptHash = /^\$2[aby]\$\d{2}\$/.test(keyOrHash);

      if (isBcryptHash) {
        // Store as hashed key record
        hashedKeys.push({
          keyHint: 'hashed',
          keyHash: keyOrHash,
          adminName: name,
          createdAt: new Date(),
          expiresAt: null,
        });
      } else {
        // Legacy plaintext key (for migration)
        legacyKeys.set(keyOrHash, name);
      }
    }

    return { legacyKeys, hashedKeys };
  });

/**
 * Price IDs schema: "tier:priceId,tier:priceId"
 */
const priceIdsSchema = z
  .string()
  .transform((val) => {
    const prices = new Map<string, string>();
    if (!val) return prices;
    for (const pair of val.split(',')) {
      const [tier, priceId] = pair.split(':');
      if (tier && priceId) {
        prices.set(tier.trim(), priceId.trim());
      }
    }
    return prices;
  });

/**
 * Configuration schema with Zod validation
 */
const configSchema = z.object({
  // Berachain RPC Configuration
  chain: z.object({
    rpcUrls: urlListSchema, // Support multiple RPC URLs for resilience
    bgtAddress: addressSchema,
    // DEPRECATED: rewardVaultAddresses is no longer used
    // Eligibility is now determined by balanceOf + burn detection
    rewardVaultAddresses: z
      .string()
      .optional()
      .default('')
      .transform((val) => (val ? val.split(',').map((addr) => addr.trim()).filter(Boolean) : []))
      .pipe(z.array(addressSchema.or(z.string().length(0)))),
  }),

  // trigger.dev Configuration
  triggerDev: z.object({
    projectId: z.string().min(1),
    secretKey: z.string().min(1),
  }),

  // Paddle Configuration (Paddle Migration - Sprint 2)
  // Sprint 80 (CRIT-1): webhookSecret is required when billing is enabled
  paddle: z.object({
    apiKey: z.string().min(1).optional(),
    // SECURITY (Sprint 80 CRIT-1): Webhook secret MUST be set when billing is enabled
    // This prevents authentication bypass attacks on the billing webhook endpoint
    webhookSecret: z.string().min(1).optional(),
    clientToken: z.string().min(1).optional(),
    environment: z.enum(['sandbox', 'production']).default('sandbox'),
    priceIds: priceIdsSchema,
    // One-time product price IDs (nested structure for cleaner access)
    oneTimePriceIds: z.object({
      badge: z.string().optional(),
      boost: z.string().optional(),
      boost1Month: z.string().optional(),
      boost3Month: z.string().optional(),
      boost6Month: z.string().optional(),
      boost12Month: z.string().optional(),
    }),
  }),

  // Redis Configuration (v4.0 - Sprint 23)
  redis: z.object({
    url: z.string().url().optional(),
    maxRetries: z.coerce.number().int().min(0).max(10).default(3),
    connectTimeout: z.coerce.number().int().min(1000).max(30000).default(5000),
    // TTL for entitlement cache in seconds (5 minutes default)
    entitlementTtl: z.coerce.number().int().min(60).max(3600).default(300),
  }),

  // Vault Configuration (Sprint 71: Vault Transit Integration - CRIT-2)
  vault: z.object({
    // Vault server address (e.g., 'https://vault.honeyjar.xyz')
    addr: z.string().url().optional(),
    // Vault authentication token
    token: z.string().optional(),
    // Optional Vault namespace (for Vault Enterprise)
    namespace: z.string().optional(),
    // Default signing key name
    signingKeyName: z.string().default('arrakis-signing'),
    // Request timeout in milliseconds
    requestTimeout: z.coerce.number().int().min(1000).max(30000).default(5000),
    // Secret cache TTL in seconds (1 hour default)
    secretCacheTtl: z.coerce.number().int().min(60).max(86400).default(3600),
  }),

  // Feature Flags (v4.0 - Sprint 23)
  // NOTE: Uses envBooleanSchema instead of z.coerce.boolean() because
  // z.coerce.boolean() incorrectly coerces "false" string to true
  features: z.object({
    // Enable Paddle billing integration
    billingEnabled: envBooleanSchema.default(false),
    // Enable Gatekeeper feature gating
    gatekeeperEnabled: envBooleanSchema.default(false),
    // Enable Redis caching
    redisEnabled: envBooleanSchema.default(false),
    // Enable score badges (Sprint 27)
    badgesEnabled: envBooleanSchema.default(true),
    // Enable Telegram bot (v4.1 - Sprint 30)
    telegramEnabled: envBooleanSchema.default(false),
    // Enable Vault secrets management (Sprint 71)
    vaultEnabled: envBooleanSchema.default(false),
    // Enable Gateway Proxy pattern (Sprint GW-5)
    // When enabled, sietch delegates Discord Gateway to Ingestor service
    gatewayProxyEnabled: envBooleanSchema.default(false),
  }),

  // Telegram Configuration (v4.1 - Sprint 30)
  telegram: z.object({
    botToken: z.string().optional(),
    webhookSecret: z.string().optional(),
    webhookUrl: z.string().url().optional(),
    verifyCallbackUrl: z.string().url().optional(),
  }),

  // Discord Configuration
  discord: z.object({
    botToken: z.string().min(1),
    guildId: z.string().min(1),
    channels: z.object({
      theDoor: z.string().min(1),
      census: z.string().min(1),
      // Social Layer channels (v2.0)
      sietchLounge: z.string().optional(),
      naibCouncil: z.string().optional(),
      introductions: z.string().optional(),
      // Cave Entrance channel (v2.1) - for aspiring members in positions 70-100
      caveEntrance: z.string().optional(),
      // The Oasis channel (v3.0 - Sprint 17) - exclusive for Water Sharer badge holders
      oasis: z.string().optional(),
      // Announcements channel (v3.0 - Sprint 20) - weekly digest posts
      announcements: z.string().optional(),
    }),
    roles: z.object({
      naib: z.string().min(1),
      fedaykin: z.string().min(1),
      // Dynamic roles (v2.0) - assigned by Sietch bot based on badges/tenure
      onboarded: z.string().optional(),
      engaged: z.string().optional(),
      veteran: z.string().optional(),
      trusted: z.string().optional(),
      // Naib dynamics roles (v2.1) - assigned based on Naib seat status
      formerNaib: z.string().optional(),
      // Cave Entrance role (v2.1) - assigned to waitlist registrations
      taqwa: z.string().optional(),
      // Tier roles (v3.0) - assigned based on BGT threshold
      hajra: z.string().optional(),
      ichwan: z.string().optional(),
      qanat: z.string().optional(),
      sihaya: z.string().optional(),
      mushtamal: z.string().optional(),
      sayyadina: z.string().optional(),
      usul: z.string().optional(),
    }),
  }),

  // API Configuration
  api: z.object({
    port: z.coerce.number().int().min(1).max(65535).default(3000),
    host: z.string().default('0.0.0.0'),
    adminApiKeys: adminApiKeysSchema,
  }),

  // Database Configuration (Sprint 70: PostgreSQL + RLS Migration)
  database: z.object({
    // PostgreSQL connection URL (required for production)
    url: z.string().url().optional(),
    // SQLite path (deprecated - for migration only)
    path: z.string().optional(),
  }),

  // Logging Configuration
  logging: z.object({
    level: z.enum(['trace', 'debug', 'info', 'warn', 'error', 'fatal']).default('info'),
  }),

  // Grace Period Configuration
  gracePeriod: z.object({
    hours: z.coerce.number().int().min(1).default(24),
  }),

  // ==========================================================================
  // Sprint 81: Security Configuration (HIGH-2, MED-1, MED-7)
  // ==========================================================================

  // Security Configuration
  security: z.object({
    // API Key pepper for HMAC operations
    // MED-1: Must not be the default value in production
    apiKeyPepper: z.string().min(1).default('CHANGE_ME_IN_PRODUCTION'),
    // Rate limit salt for IP hashing
    rateLimitSalt: z.string().min(1).optional(),
    // Webhook secret for KillSwitch protocol
    webhookSecret: z.string().min(1).optional(),
    // Allowed webhooks for KillSwitch (comma-separated)
    allowedWebhooks: z.string().optional().transform((val) =>
      val ? val.split(',').map((w) => w.trim()).filter(Boolean) : []
    ),
  }),

  // CORS Configuration (MED-7)
  cors: z.object({
    // Allowed origins (comma-separated) - '*' allows all (not recommended for production)
    allowedOrigins: z.string().default('*').transform((val) =>
      val === '*' ? ['*'] : val.split(',').map((o) => o.trim()).filter(Boolean)
    ),
    // Allow credentials (cookies, auth headers)
    credentials: envBooleanSchema.default(false),
    // Max age for preflight cache in seconds
    maxAge: z.coerce.number().int().min(0).max(86400).default(86400),
  }),

  // Verification Configuration (HIGH-2 - Direct env var access)
  verification: z.object({
    // Base URL for verification links (e.g., https://api.arrakis.community)
    // Sprint 81: proper optional URL handling - invalid URLs become undefined
    baseUrl: z.string().optional().transform((val) => {
      if (!val || val.length === 0) return undefined;
      try {
        new URL(val);
        return val;
      } catch {
        return undefined;
      }
    }),
  }),

  // Duo MFA Configuration (HIGH-2 - Direct env var access)
  mfa: z.object({
    duo: z.object({
      integrationKey: z.string().min(1).optional(),
      secretKey: z.string().min(1).optional(),
      apiHostname: z.string().min(1).optional(),
    }),
  }),

  // Boost Configuration (HIGH-2 - Direct env var access)
  boost: z.object({
    thresholds: z.object({
      level1: z.coerce.number().int().min(0).default(1),
      level2: z.coerce.number().int().min(0).default(5),
      level3: z.coerce.number().int().min(0).default(10),
    }),
    pricing: z.object({
      pricePerMonthCents: z.coerce.number().int().min(0).default(499),
    }),
    // JSON bundles configuration (optional)
    bundles: z.string().optional(),
  }),

  // Upgrade URL for billing gatekeeper (Sprint 81: proper optional URL handling)
  // Accepts valid URL, or undefined. Non-URL strings are coerced to undefined.
  upgradeUrl: z.string().optional().transform((val) => {
    if (!val || val.length === 0) return undefined;
    try {
      new URL(val); // Validate URL format
      return val;
    } catch {
      return undefined; // Invalid URL becomes undefined
    }
  }),

  // Base URL for badge routes (Sprint 81: proper optional URL handling)
  // Accepts valid URL, or undefined. Non-URL strings are coerced to undefined.
  baseUrl: z.string().optional().transform((val) => {
    if (!val || val.length === 0) return undefined;
    try {
      new URL(val); // Validate URL format
      return val;
    } catch {
      return undefined; // Invalid URL becomes undefined
    }
  }),

  // Social Layer Configuration (v2.0)
  socialLayer: z.object({
    // Activity decay settings
    activity: z.object({
      // Decay rate per period (0.0-1.0)
      decayRate: z.coerce.number().min(0).max(1).default(0.1),
      // Decay period in hours
      decayPeriodHours: z.coerce.number().int().min(1).default(6),
      // Points per activity type
      points: z.object({
        message: z.coerce.number().int().min(0).default(1),
        reactionGiven: z.coerce.number().int().min(0).default(1),
        reactionReceived: z.coerce.number().int().min(0).default(2),
      }),
    }),
    // Profile settings
    profile: z.object({
      // Nym change cooldown in days
      nymChangeCooldownDays: z.coerce.number().int().min(0).default(30),
      // Launch date for OG badge calculation
      launchDate: z.string().datetime().optional(),
      // Max bio length
      maxBioLength: z.coerce.number().int().min(0).default(160),
    }),
    // Avatar settings
    avatar: z.object({
      // Default size in pixels
      defaultSize: z.coerce.number().int().min(32).max(512).default(200),
      // Grid dimensions for drunken bishop
      gridWidth: z.coerce.number().int().min(5).max(50).default(17),
      gridHeight: z.coerce.number().int().min(5).max(50).default(9),
    }),
    // Image processing settings
    image: z.object({
      // Target PFP size
      pfpSize: z.coerce.number().int().min(64).max(512).default(256),
      // Max file size in KB
      maxFileSizeKB: z.coerce.number().int().min(100).max(2048).default(500),
      // WebP quality
      webpQuality: z.coerce.number().int().min(1).max(100).default(80),
    }),
  }),
});

/**
 * Parse and validate configuration from environment variables
 */
function parseConfig() {
  const rawConfig = {
    chain: {
      rpcUrls: process.env.BERACHAIN_RPC_URLS ?? process.env.BERACHAIN_RPC_URL ?? '',
      bgtAddress: process.env.BGT_ADDRESS ?? '',
      rewardVaultAddresses: process.env.REWARD_VAULT_ADDRESSES ?? '',
    },
    triggerDev: {
      projectId: process.env.TRIGGER_PROJECT_ID ?? '',
      secretKey: process.env.TRIGGER_SECRET_KEY ?? '',
    },
    // Paddle Configuration (Paddle Migration - Sprint 2)
    paddle: {
      apiKey: process.env.PADDLE_API_KEY,
      webhookSecret: process.env.PADDLE_WEBHOOK_SECRET,
      clientToken: process.env.PADDLE_CLIENT_TOKEN,
      environment: process.env.PADDLE_ENVIRONMENT ?? 'sandbox',
      priceIds: process.env.PADDLE_PRICE_IDS ?? '',
      oneTimePriceIds: {
        badge: process.env.PADDLE_BADGE_PRICE_ID,
        boost: process.env.PADDLE_BOOST_PRICE_ID,
        boost1Month: process.env.PADDLE_BOOST_1_MONTH_PRICE_ID,
        boost3Month: process.env.PADDLE_BOOST_3_MONTH_PRICE_ID,
        boost6Month: process.env.PADDLE_BOOST_6_MONTH_PRICE_ID,
        boost12Month: process.env.PADDLE_BOOST_12_MONTH_PRICE_ID,
      },
    },
    // Redis Configuration (v4.0 - Sprint 23)
    redis: {
      url: process.env.REDIS_URL,
      maxRetries: process.env.REDIS_MAX_RETRIES ?? '3',
      connectTimeout: process.env.REDIS_CONNECT_TIMEOUT ?? '5000',
      entitlementTtl: process.env.REDIS_ENTITLEMENT_TTL ?? '300',
    },
    // Vault Configuration (Sprint 71: Vault Transit Integration - CRIT-2)
    vault: {
      addr: process.env.VAULT_ADDR,
      token: process.env.VAULT_TOKEN,
      namespace: process.env.VAULT_NAMESPACE,
      signingKeyName: process.env.VAULT_SIGNING_KEY_NAME ?? 'arrakis-signing',
      requestTimeout: process.env.VAULT_REQUEST_TIMEOUT ?? '5000',
      secretCacheTtl: process.env.VAULT_SECRET_CACHE_TTL ?? '3600',
    },
    // Feature Flags (v4.0 - Sprint 23)
    features: {
      billingEnabled: process.env.FEATURE_BILLING_ENABLED ?? 'false',
      gatekeeperEnabled: process.env.FEATURE_GATEKEEPER_ENABLED ?? 'false',
      redisEnabled: process.env.FEATURE_REDIS_ENABLED ?? 'false',
      telegramEnabled: process.env.FEATURE_TELEGRAM_ENABLED ?? 'false',
      vaultEnabled: process.env.FEATURE_VAULT_ENABLED ?? 'false',
      gatewayProxyEnabled: process.env.USE_GATEWAY_PROXY ?? 'false',
    },
    // Telegram Configuration (v4.1 - Sprint 30)
    telegram: {
      botToken: process.env.TELEGRAM_BOT_TOKEN,
      webhookSecret: process.env.TELEGRAM_WEBHOOK_SECRET,
      webhookUrl: process.env.TELEGRAM_WEBHOOK_URL,
      verifyCallbackUrl: process.env.TELEGRAM_VERIFY_CALLBACK_URL,
    },
    discord: {
      botToken: process.env.DISCORD_BOT_TOKEN ?? '',
      guildId: process.env.DISCORD_GUILD_ID ?? '',
      channels: {
        theDoor: process.env.DISCORD_CHANNEL_THE_DOOR ?? '',
        census: process.env.DISCORD_CHANNEL_CENSUS ?? '',
        // Social Layer channels (v2.0)
        sietchLounge: process.env.DISCORD_CHANNEL_SIETCH_LOUNGE,
        naibCouncil: process.env.DISCORD_CHANNEL_NAIB_COUNCIL,
        introductions: process.env.DISCORD_CHANNEL_INTRODUCTIONS,
        // Cave Entrance channel (v2.1)
        caveEntrance: process.env.DISCORD_CHANNEL_CAVE_ENTRANCE,
        // The Oasis channel (v3.0 - Sprint 17)
        oasis: process.env.DISCORD_CHANNEL_OASIS,
        // Announcements channel (v3.0 - Sprint 20)
        announcements: process.env.DISCORD_ANNOUNCEMENTS_CHANNEL_ID,
      },
      roles: {
        naib: process.env.DISCORD_ROLE_NAIB ?? '',
        fedaykin: process.env.DISCORD_ROLE_FEDAYKIN ?? '',
        // Dynamic roles (v2.0)
        onboarded: process.env.DISCORD_ROLE_ONBOARDED,
        engaged: process.env.DISCORD_ROLE_ENGAGED,
        veteran: process.env.DISCORD_ROLE_VETERAN,
        trusted: process.env.DISCORD_ROLE_TRUSTED,
        // Naib dynamics roles (v2.1)
        formerNaib: process.env.DISCORD_ROLE_FORMER_NAIB,
        // Cave Entrance role (v2.1)
        taqwa: process.env.DISCORD_ROLE_TAQWA,
        // Tier roles (v3.0)
        hajra: process.env.DISCORD_ROLE_HAJRA,
        ichwan: process.env.DISCORD_ROLE_ICHWAN,
        qanat: process.env.DISCORD_ROLE_QANAT,
        sihaya: process.env.DISCORD_ROLE_SIHAYA,
        mushtamal: process.env.DISCORD_ROLE_MUSHTAMAL,
        sayyadina: process.env.DISCORD_ROLE_SAYYADINA,
        usul: process.env.DISCORD_ROLE_USUL,
      },
    },
    api: {
      port: process.env.API_PORT ?? '3000',
      host: process.env.API_HOST ?? '0.0.0.0',
      adminApiKeys: process.env.ADMIN_API_KEYS ?? '',
    },
    database: {
      url: process.env.DATABASE_URL,
      path: process.env.DATABASE_PATH, // Deprecated - for migration only
    },
    logging: {
      level: process.env.LOG_LEVEL ?? 'info',
    },
    gracePeriod: {
      hours: process.env.GRACE_PERIOD_HOURS ?? '24',
    },
    // ==========================================================================
    // Sprint 81: Security Configuration (HIGH-2, MED-1, MED-7)
    // ==========================================================================
    security: {
      apiKeyPepper: process.env.API_KEY_PEPPER ?? 'CHANGE_ME_IN_PRODUCTION',
      rateLimitSalt: process.env.RATE_LIMIT_SALT,
      webhookSecret: process.env.WEBHOOK_SECRET,
      allowedWebhooks: process.env.ALLOWED_WEBHOOKS,
    },
    cors: {
      allowedOrigins: process.env.CORS_ALLOWED_ORIGINS ?? '*',
      credentials: process.env.CORS_CREDENTIALS ?? 'false',
      maxAge: process.env.CORS_MAX_AGE ?? '86400',
    },
    verification: {
      baseUrl: process.env.VERIFY_BASE_URL,
    },
    mfa: {
      duo: {
        integrationKey: process.env.DUO_INTEGRATION_KEY,
        secretKey: process.env.DUO_SECRET_KEY,
        apiHostname: process.env.DUO_API_HOSTNAME,
      },
    },
    boost: {
      thresholds: {
        level1: process.env.BOOST_LEVEL1_THRESHOLD ?? '1',
        level2: process.env.BOOST_LEVEL2_THRESHOLD ?? '5',
        level3: process.env.BOOST_LEVEL3_THRESHOLD ?? '10',
      },
      pricing: {
        pricePerMonthCents: process.env.BOOST_PRICE_PER_MONTH_CENTS ?? '499',
      },
      bundles: process.env.BOOST_BUNDLES,
    },
    upgradeUrl: process.env.UPGRADE_URL,
    baseUrl: process.env.BASE_URL,
    // Social Layer Configuration (v2.0)
    socialLayer: {
      activity: {
        decayRate: process.env.ACTIVITY_DECAY_RATE ?? '0.1',
        decayPeriodHours: process.env.ACTIVITY_DECAY_PERIOD_HOURS ?? '6',
        points: {
          message: process.env.ACTIVITY_POINTS_MESSAGE ?? '1',
          reactionGiven: process.env.ACTIVITY_POINTS_REACTION_GIVEN ?? '1',
          reactionReceived: process.env.ACTIVITY_POINTS_REACTION_RECEIVED ?? '2',
        },
      },
      profile: {
        nymChangeCooldownDays: process.env.NYM_CHANGE_COOLDOWN_DAYS ?? '30',
        launchDate: process.env.SOCIAL_LAYER_LAUNCH_DATE,
        maxBioLength: process.env.MAX_BIO_LENGTH ?? '160',
      },
      avatar: {
        defaultSize: process.env.AVATAR_DEFAULT_SIZE ?? '200',
        gridWidth: process.env.AVATAR_GRID_WIDTH ?? '17',
        gridHeight: process.env.AVATAR_GRID_HEIGHT ?? '9',
      },
      image: {
        pfpSize: process.env.PFP_SIZE ?? '256',
        maxFileSizeKB: process.env.MAX_PFP_SIZE_KB ?? '500',
        webpQuality: process.env.WEBP_QUALITY ?? '80',
      },
    },
  };

  const result = configSchema.safeParse(rawConfig);

  if (!result.success) {
    const errors = result.error.issues.map(
      (issue) => `  - ${issue.path.join('.')}: ${issue.message}`
    );
    logger.fatal({ errors: result.error.issues }, 'Configuration validation failed');
    throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
  }

  return result.data;
}

/**
 * Typed configuration object
 */
export interface Config {
  chain: {
    rpcUrls: string[];
    bgtAddress: Address;
    /** @deprecated No longer used - eligibility now uses balanceOf + burn detection */
    rewardVaultAddresses: Address[];
  };
  triggerDev: {
    projectId: string;
    secretKey: string;
  };
  // Paddle Configuration (Paddle Migration - Sprint 2)
  paddle: {
    apiKey?: string;
    webhookSecret?: string;
    clientToken?: string;
    environment: 'sandbox' | 'production';
    priceIds: Map<string, string>;
    oneTimePriceIds: {
      badge?: string;
      boost?: string;
      boost1Month?: string;
      boost3Month?: string;
      boost6Month?: string;
      boost12Month?: string;
    };
  };
  // Redis Configuration (v4.0 - Sprint 23)
  redis: {
    url?: string;
    maxRetries: number;
    connectTimeout: number;
    entitlementTtl: number;
  };
  // Vault Configuration (Sprint 71: Vault Transit Integration - CRIT-2)
  vault: {
    addr?: string;
    token?: string;
    namespace?: string;
    signingKeyName: string;
    requestTimeout: number;
    secretCacheTtl: number;
  };
  // Feature Flags (v4.0 - Sprint 23)
  features: {
    billingEnabled: boolean;
    gatekeeperEnabled: boolean;
    redisEnabled: boolean;
    badgesEnabled: boolean;
    telegramEnabled: boolean;
    vaultEnabled: boolean;
  };
  // Telegram Configuration (v4.1 - Sprint 30)
  telegram: {
    botToken?: string;
    webhookSecret?: string;
    webhookUrl?: string;
    verifyCallbackUrl?: string;
  };
  discord: {
    botToken: string;
    guildId: string;
    channels: {
      theDoor: string;
      census: string;
      // Social Layer channels (v2.0)
      sietchLounge?: string;
      naibCouncil?: string;
      introductions?: string;
      // Cave Entrance channel (v2.1)
      caveEntrance?: string;
      // The Oasis channel (v3.0 - Sprint 17)
      oasis?: string;
      // Announcements channel (v3.0 - Sprint 20)
      announcements?: string;
    };
    roles: {
      naib: string;
      fedaykin: string;
      // Dynamic roles (v2.0)
      onboarded?: string;
      engaged?: string;
      veteran?: string;
      trusted?: string;
      // Naib dynamics roles (v2.1)
      formerNaib?: string;
      // Cave Entrance role (v2.1)
      taqwa?: string;
      // Tier roles (v3.0)
      hajra?: string;
      ichwan?: string;
      qanat?: string;
      sihaya?: string;
      mushtamal?: string;
      sayyadina?: string;
      usul?: string;
    };
  };
  api: {
    port: number;
    host: string;
    /** Sprint 73 (HIGH-1): Supports legacy plaintext and bcrypt-hashed keys */
    adminApiKeys: {
      /** Legacy plaintext keys (for migration) - DEPRECATED */
      legacyKeys: Map<string, string>;
      /** Bcrypt-hashed keys (recommended) */
      hashedKeys: AdminApiKeyRecord[];
    };
  };
  database: {
    // PostgreSQL connection URL (required for production)
    url?: string;
    // SQLite path (deprecated - for migration only)
    path?: string;
  };
  logging: {
    level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  };
  gracePeriod: {
    hours: number;
  };
  // ==========================================================================
  // Sprint 81: Security Configuration (HIGH-2, MED-1, MED-7)
  // ==========================================================================
  security: {
    apiKeyPepper: string;
    rateLimitSalt?: string;
    webhookSecret?: string;
    allowedWebhooks: string[];
  };
  cors: {
    allowedOrigins: string[];
    credentials: boolean;
    maxAge: number;
  };
  verification: {
    baseUrl?: string;
  };
  mfa: {
    duo: {
      integrationKey?: string;
      secretKey?: string;
      apiHostname?: string;
    };
  };
  boost: {
    thresholds: {
      level1: number;
      level2: number;
      level3: number;
    };
    pricing: {
      pricePerMonthCents: number;
    };
    bundles?: string;
  };
  upgradeUrl?: string;
  baseUrl?: string;
  // Social Layer Configuration (v2.0)
  socialLayer: {
    activity: {
      decayRate: number;
      decayPeriodHours: number;
      points: {
        message: number;
        reactionGiven: number;
        reactionReceived: number;
      };
    };
    profile: {
      nymChangeCooldownDays: number;
      launchDate?: string;
      maxBioLength: number;
    };
    avatar: {
      defaultSize: number;
      gridWidth: number;
      gridHeight: number;
    };
    image: {
      pfpSize: number;
      maxFileSizeKB: number;
      webpQuality: number;
    };
  };
}

// Parse configuration at module load time
const parsedConfig = parseConfig();

/**
 * Startup validation for critical configuration combinations
 * Fails fast if billing is enabled without required secrets
 */
function validateStartupConfig(cfg: typeof parsedConfig): void {
  // SECURITY: Require webhook secret when billing is enabled
  if (cfg.features.billingEnabled && cfg.paddle.apiKey && !cfg.paddle.webhookSecret) {
    logger.fatal('PADDLE_WEBHOOK_SECRET is required when billing is enabled');
    throw new Error(
      'Missing required configuration: PADDLE_WEBHOOK_SECRET must be set when FEATURE_BILLING_ENABLED=true and PADDLE_API_KEY is configured'
    );
  }

  // Sprint 70: Warn if using SQLite path instead of PostgreSQL URL
  if (cfg.database.path && !cfg.database.url) {
    logger.warn(
      { path: cfg.database.path },
      'DATABASE_PATH is deprecated. Use DATABASE_URL for PostgreSQL in production. SQLite is only supported for migration.'
    );
  }

  // Sprint 70: Validate DATABASE_URL is set in production (when not in test mode)
  const isTest = process.env.NODE_ENV === 'test' || process.env.VITEST === 'true';
  const isProduction = process.env.NODE_ENV === 'production';
  if (isProduction && !cfg.database.url) {
    logger.fatal('DATABASE_URL is required in production for PostgreSQL with RLS');
    throw new Error(
      'Missing required configuration: DATABASE_URL must be set in production. PostgreSQL with Row-Level Security is required for multi-tenant isolation.'
    );
  }

  // Sprint 70: Validate one database config is present (except in test mode)
  if (!isTest && !cfg.database.url && !cfg.database.path) {
    logger.fatal('No database configuration provided');
    throw new Error(
      'Missing required configuration: Either DATABASE_URL (PostgreSQL) or DATABASE_PATH (SQLite - deprecated) must be set.'
    );
  }

  // Sprint 71: Validate Vault configuration when enabled
  if (cfg.features.vaultEnabled) {
    if (!cfg.vault.addr) {
      logger.fatal('VAULT_ADDR is required when Vault is enabled');
      throw new Error(
        'Missing required configuration: VAULT_ADDR must be set when FEATURE_VAULT_ENABLED=true'
      );
    }
    if (!cfg.vault.token) {
      logger.fatal('VAULT_TOKEN is required when Vault is enabled');
      throw new Error(
        'Missing required configuration: VAULT_TOKEN must be set when FEATURE_VAULT_ENABLED=true'
      );
    }
  }

  // Sprint 71: Warn about sensitive env vars that should migrate to Vault
  if (isProduction && !cfg.features.vaultEnabled) {
    logger.warn(
      'SECURITY WARNING: Running in production without Vault. Sensitive secrets are stored in environment variables. Consider enabling FEATURE_VAULT_ENABLED=true for enhanced security.'
    );
  }

  // ==========================================================================
  // Sprint 81: Security Configuration Validation
  // ==========================================================================

  // MED-1: Reject default API_KEY_PEPPER value in production
  if (isProduction && cfg.security.apiKeyPepper === 'CHANGE_ME_IN_PRODUCTION') {
    logger.fatal('API_KEY_PEPPER must be changed from default value in production');
    throw new Error(
      'SECURITY ERROR: API_KEY_PEPPER is set to default value "CHANGE_ME_IN_PRODUCTION". ' +
        'Generate a secure 32+ character random string for production use.'
    );
  }

  // MED-1: Enforce minimum pepper length in production
  if (isProduction && cfg.security.apiKeyPepper.length < 32) {
    logger.fatal('API_KEY_PEPPER must be at least 32 characters in production');
    throw new Error(
      'SECURITY ERROR: API_KEY_PEPPER must be at least 32 characters in production. ' +
        `Current length: ${cfg.security.apiKeyPepper.length}`
    );
  }

  // MED-5: Require Telegram webhook secret when webhook URL is configured
  if (cfg.features.telegramEnabled && cfg.telegram.webhookUrl && !cfg.telegram.webhookSecret) {
    logger.fatal('TELEGRAM_WEBHOOK_SECRET is required when webhook URL is configured');
    throw new Error(
      'Missing required configuration: TELEGRAM_WEBHOOK_SECRET must be set when ' +
        'FEATURE_TELEGRAM_ENABLED=true and TELEGRAM_WEBHOOK_URL is configured. ' +
        'This prevents unauthorized webhook calls.'
    );
  }

  // MED-7: Warn about wildcard CORS in production
  if (isProduction && cfg.cors.allowedOrigins.includes('*')) {
    logger.warn(
      'SECURITY WARNING: CORS is configured to allow all origins (*). ' +
        'Consider setting CORS_ALLOWED_ORIGINS to specific domains in production.'
    );
  }

  // ==========================================================================
  // Sprint 83: Example Value Validation (LOW-2)
  // ==========================================================================

  if (isProduction) {
    // Patterns that indicate placeholder/example values
    const examplePatterns = [
      /^your_.*_here$/i,     // your_secret_here, your_token_here
      /^change_?me$/i,       // changeme, change_me
      /^example$/i,          // example
      /^xxx+$/i,             // xxx, xxxx
      /^placeholder$/i,      // placeholder
      /^test_?secret$/i,     // testsecret, test_secret
      /^todo$/i,             // todo
      /^replace_?me$/i,      // replaceme, replace_me
    ];

    /**
     * Check if a value matches any example pattern
     */
    const isExampleValue = (value: string | undefined): boolean => {
      if (!value) return false;
      return examplePatterns.some((pattern) => pattern.test(value));
    };

    // Check sensitive configuration values
    const sensitiveFields: Array<{ name: string; value: string | undefined }> = [
      { name: 'DISCORD_BOT_TOKEN', value: cfg.discord.botToken },
      { name: 'PADDLE_API_KEY', value: cfg.paddle.apiKey },
      { name: 'PADDLE_WEBHOOK_SECRET', value: cfg.paddle.webhookSecret },
      { name: 'TELEGRAM_BOT_TOKEN', value: cfg.telegram.botToken },
      { name: 'TELEGRAM_WEBHOOK_SECRET', value: cfg.telegram.webhookSecret },
      { name: 'VAULT_TOKEN', value: cfg.vault.token },
      { name: 'RATE_LIMIT_SALT', value: cfg.security.rateLimitSalt },
      { name: 'WEBHOOK_SECRET', value: cfg.security.webhookSecret },
      { name: 'DUO_SECRET_KEY', value: cfg.mfa.duo.secretKey },
    ];

    for (const field of sensitiveFields) {
      if (isExampleValue(field.value)) {
        logger.fatal(
          { field: field.name },
          `SECURITY ERROR: ${field.name} appears to be a placeholder value`
        );
        throw new Error(
          `SECURITY ERROR: ${field.name} is set to a placeholder value (e.g., "your_*_here", "changeme"). ` +
            'Replace with a real secret before deploying to production.'
        );
      }
    }

    logger.info('Sprint 83 (LOW-2): Example value validation passed');
  }
}

// Run startup validation
validateStartupConfig(parsedConfig);

/**
 * Validated and typed configuration
 */
export const config: Config = {
  chain: {
    rpcUrls: parsedConfig.chain.rpcUrls,
    bgtAddress: parsedConfig.chain.bgtAddress as Address,
    rewardVaultAddresses: parsedConfig.chain.rewardVaultAddresses as Address[],
  },
  triggerDev: parsedConfig.triggerDev,
  paddle: parsedConfig.paddle,
  redis: parsedConfig.redis,
  vault: parsedConfig.vault,
  features: parsedConfig.features,
  telegram: parsedConfig.telegram,
  discord: parsedConfig.discord,
  api: parsedConfig.api,
  database: parsedConfig.database,
  logging: parsedConfig.logging,
  gracePeriod: parsedConfig.gracePeriod,
  // Sprint 81: Security configuration
  security: parsedConfig.security,
  cors: parsedConfig.cors,
  verification: parsedConfig.verification,
  mfa: parsedConfig.mfa,
  boost: parsedConfig.boost,
  upgradeUrl: parsedConfig.upgradeUrl,
  baseUrl: parsedConfig.baseUrl,
  socialLayer: parsedConfig.socialLayer,
};

// =============================================================================
// API Key Validation (Sprint 73 - HIGH-1 Security Fix)
// =============================================================================

// Singleton service instance for bcrypt validation
let adminApiKeyService: AdminApiKeyService | null = null;

function getApiKeyService(): AdminApiKeyService {
  if (!adminApiKeyService) {
    adminApiKeyService = new AdminApiKeyService({ bcryptRounds: 12 });
  }
  return adminApiKeyService;
}

/**
 * Validate an admin API key (LEGACY - SYNCHRONOUS)
 *
 * DEPRECATED: Use validateApiKeyAsync for new code.
 *
 * This function only validates legacy plaintext keys for backward compatibility.
 * Bcrypt-hashed keys CANNOT be validated with this function.
 *
 * @param apiKey - API key to validate
 * @returns Admin name if valid plaintext key, undefined otherwise
 */
// Sprint 83 (LOW-1): Legacy API key sunset tracking
// Sunset date: 90 days from January 14, 2026 = April 14, 2026
const LEGACY_KEY_SUNSET_DATE = '2026-04-14';
let legacyKeyUsageCount = 0;

/**
 * Get legacy key usage metrics
 *
 * Sprint 83 (LOW-1): Track legacy key usage for monitoring
 *
 * @returns Current legacy key usage count
 */
export function getLegacyKeyUsageCount(): number {
  return legacyKeyUsageCount;
}

/**
 * Reset legacy key usage count (for testing)
 */
export function resetLegacyKeyUsageCount(): void {
  legacyKeyUsageCount = 0;
}

export function validateApiKey(apiKey: string): string | undefined {
  // Sprint 73: Only check legacy keys synchronously
  // Log warning if legacy keys are being used
  const adminName = config.api.adminApiKeys.legacyKeys.get(apiKey);
  if (adminName) {
    // Sprint 83 (LOW-1): Enhanced warning with sunset date
    legacyKeyUsageCount++;
    logger.warn(
      {
        adminName,
        keyHint: apiKey.substring(0, 8),
        sunsetDate: LEGACY_KEY_SUNSET_DATE,
        usageCount: legacyKeyUsageCount,
        metric: 'sietch_legacy_api_key_usage_total',
      },
      `DEPRECATION WARNING: Using legacy plaintext API key. Support ends ${LEGACY_KEY_SUNSET_DATE}. Migrate to bcrypt-hashed keys.`
    );
  }
  return adminName;
}

/**
 * Validate an admin API key (ASYNC - RECOMMENDED)
 *
 * Sprint 73 (HIGH-1): Secure API key validation with bcrypt.
 *
 * Checks both bcrypt-hashed keys (recommended) and legacy plaintext keys.
 * Uses constant-time comparison via bcrypt.compare() to prevent timing attacks.
 *
 * @param apiKey - API key to validate
 * @returns Admin name if valid, undefined if invalid
 */
export async function validateApiKeyAsync(apiKey: string): Promise<string | undefined> {
  if (!apiKey || typeof apiKey !== 'string') {
    return undefined;
  }

  const { legacyKeys, hashedKeys } = config.api.adminApiKeys;

  // First try bcrypt-hashed keys (recommended)
  if (hashedKeys.length > 0) {
    const keyService = getApiKeyService();
    const result = await keyService.validateKeyAgainstRecords(apiKey, hashedKeys);
    if (result.valid && result.adminName) {
      return result.adminName;
    }
  }

  // Fall back to legacy plaintext keys (deprecated)
  const legacyAdmin = legacyKeys.get(apiKey);
  if (legacyAdmin) {
    // Sprint 83 (LOW-1): Enhanced warning with sunset date
    legacyKeyUsageCount++;
    logger.warn(
      {
        adminName: legacyAdmin,
        keyHint: apiKey.substring(0, 8),
        sunsetDate: LEGACY_KEY_SUNSET_DATE,
        usageCount: legacyKeyUsageCount,
        metric: 'sietch_legacy_api_key_usage_total',
      },
      `DEPRECATION WARNING: Using legacy plaintext API key. Support ends ${LEGACY_KEY_SUNSET_DATE}. Migrate to bcrypt-hashed keys.`
    );
    return legacyAdmin;
  }

  return undefined;
}

/**
 * Check if any bcrypt-hashed keys are configured
 *
 * Returns true if at least one bcrypt-hashed key is configured.
 * Use this to determine if async validation is available.
 */
export function hasBcryptKeys(): boolean {
  return config.api.adminApiKeys.hashedKeys.length > 0;
}

/**
 * Check if any legacy plaintext keys are configured
 *
 * Returns true if legacy keys exist. Logs warning in production.
 * Use this to prompt migration to bcrypt keys.
 */
export function hasLegacyKeys(): boolean {
  return config.api.adminApiKeys.legacyKeys.size > 0;
}

/**
 * Tier role colors for Discord (hex values)
 * Used when creating roles programmatically
 */
export const TIER_ROLE_COLORS = {
  hajra: 0xC2B280,     // Sand
  ichwan: 0xFD7E14,    // Orange
  qanat: 0x17A2B8,     // Cyan
  sihaya: 0x28A745,    // Green
  mushtamal: 0x20C997, // Teal
  sayyadina: 0x6610F2, // Indigo
  usul: 0x9B59B6,      // Purple
  fedaykin: 0x4169E1,  // Blue
  naib: 0xFFD700,      // Gold
} as const;

/**
 * Get tier role ID from config
 * Returns the Discord role ID for a given tier, or undefined if not configured
 */
export function getTierRoleId(tier: string): string | undefined {
  const roles = config.discord.roles;
  switch (tier) {
    case 'hajra':
      return roles.hajra;
    case 'ichwan':
      return roles.ichwan;
    case 'qanat':
      return roles.qanat;
    case 'sihaya':
      return roles.sihaya;
    case 'mushtamal':
      return roles.mushtamal;
    case 'sayyadina':
      return roles.sayyadina;
    case 'usul':
      return roles.usul;
    case 'fedaykin':
      return roles.fedaykin;
    case 'naib':
      return roles.naib;
    default:
      return undefined;
  }
}

/**
 * Check if all tier roles are configured
 * Returns list of missing tier role names
 */
export function getMissingTierRoles(): string[] {
  const missing: string[] = [];
  const roles = config.discord.roles;

  // BGT-based tiers (optional)
  if (!roles.hajra) missing.push('hajra');
  if (!roles.ichwan) missing.push('ichwan');
  if (!roles.qanat) missing.push('qanat');
  if (!roles.sihaya) missing.push('sihaya');
  if (!roles.mushtamal) missing.push('mushtamal');
  if (!roles.sayyadina) missing.push('sayyadina');
  if (!roles.usul) missing.push('usul');
  // Rank-based tiers (required)
  if (!roles.fedaykin) missing.push('fedaykin');
  if (!roles.naib) missing.push('naib');

  return missing;
}

/**
 * Check if The Oasis channel is configured
 */
export function isOasisChannelConfigured(): boolean {
  return !!config.discord.channels.oasis;
}

/**
 * Get The Oasis channel ID
 * Returns undefined if not configured
 */
export function getOasisChannelId(): string | undefined {
  return config.discord.channels.oasis;
}

// =============================================================================
// Billing Configuration Helpers (v4.0 - Sprint 23)
// =============================================================================

/**
 * Check if billing is enabled
 */
export function isBillingEnabled(): boolean {
  return config.features.billingEnabled && !!config.paddle.apiKey;
}

/**
 * Check if Paddle billing is enabled and configured
 */
export function isPaddleEnabled(): boolean {
  return config.features.billingEnabled && !!config.paddle.apiKey;
}

/**
 * Check if Gatekeeper feature gating is enabled
 */
export function isGatekeeperEnabled(): boolean {
  return config.features.gatekeeperEnabled;
}

/**
 * Check if Redis caching is enabled and configured
 */
export function isRedisEnabled(): boolean {
  return config.features.redisEnabled && !!config.redis.url;
}

/**
 * Get Paddle price ID for a subscription tier
 * Returns undefined if not configured
 */
export function getPaddlePriceId(tier: string): string | undefined {
  return config.paddle.priceIds.get(tier);
}

/**
 * Check if all required Paddle configuration is present
 * Returns list of missing configuration keys
 */
export function getMissingPaddleConfig(): string[] {
  const missing: string[] = [];

  if (!config.paddle.apiKey) missing.push('PADDLE_API_KEY');
  if (!config.paddle.webhookSecret) missing.push('PADDLE_WEBHOOK_SECRET');
  if (!config.paddle.clientToken) missing.push('PADDLE_CLIENT_TOKEN');
  if (config.paddle.priceIds.size === 0) missing.push('PADDLE_PRICE_IDS');

  return missing;
}

/**
 * Subscription tier pricing information
 * Monthly prices in USD
 */
export const SUBSCRIPTION_TIERS = {
  starter: { price: 0, maxMembers: 100, name: 'Starter' },
  basic: { price: 29, maxMembers: 500, name: 'Basic' },
  premium: { price: 99, maxMembers: 1000, name: 'Premium' },
  exclusive: { price: 199, maxMembers: 2500, name: 'Exclusive' },
  elite: { price: 449, maxMembers: 10000, name: 'Elite' },
  enterprise: { price: 0, maxMembers: Infinity, name: 'Enterprise' }, // Custom pricing
} as const;

/**
 * Get subscription tier info
 */
export function getSubscriptionTierInfo(tier: string): typeof SUBSCRIPTION_TIERS[keyof typeof SUBSCRIPTION_TIERS] | undefined {
  return SUBSCRIPTION_TIERS[tier as keyof typeof SUBSCRIPTION_TIERS];
}

// =============================================================================
// Telegram Configuration Helpers (v4.1 - Sprint 30)
// =============================================================================

/**
 * Check if Telegram bot is enabled and configured
 */
export function isTelegramEnabled(): boolean {
  return config.features.telegramEnabled && !!config.telegram.botToken;
}

/**
 * Check if all required Telegram configuration is present
 * Returns list of missing configuration keys
 */
export function getMissingTelegramConfig(): string[] {
  const missing: string[] = [];

  if (!config.telegram.botToken) missing.push('TELEGRAM_BOT_TOKEN');
  if (!config.telegram.webhookSecret) missing.push('TELEGRAM_WEBHOOK_SECRET');

  return missing;
}

/**
 * Check if Telegram is in production mode (webhook) vs development (polling)
 */
export function isTelegramWebhookMode(): boolean {
  return !!config.telegram.webhookUrl;
}

// =============================================================================
// Database Configuration Helpers (Sprint 70: PostgreSQL + RLS Migration)
// =============================================================================

/**
 * Check if PostgreSQL is configured
 */
export function isPostgreSQLEnabled(): boolean {
  return !!config.database.url;
}

/**
 * Get database URL for PostgreSQL connections
 * Returns undefined if only SQLite path is configured
 */
export function getDatabaseUrl(): string | undefined {
  return config.database.url;
}

/**
 * Get database path for SQLite (deprecated)
 * Returns undefined if PostgreSQL URL is configured
 */
export function getDatabasePath(): string | undefined {
  return config.database.path;
}

/**
 * Get database connection string with fallback
 * Prioritizes PostgreSQL URL over SQLite path
 * Returns default SQLite path for tests if nothing configured
 */
export function getDatabaseConnection(): { type: 'postgresql' | 'sqlite'; connectionString: string } {
  if (config.database.url) {
    return { type: 'postgresql', connectionString: config.database.url };
  }
  if (config.database.path) {
    return { type: 'sqlite', connectionString: config.database.path };
  }
  // Default for tests
  return { type: 'sqlite', connectionString: './data/sietch.db' };
}

/**
 * Check if multi-tenant RLS is available
 * RLS requires PostgreSQL - SQLite does not support row-level security
 */
export function isRLSAvailable(): boolean {
  return isPostgreSQLEnabled();
}

/**
 * Get missing database configuration
 * Returns list of missing configuration keys
 */
export function getMissingDatabaseConfig(): string[] {
  const missing: string[] = [];

  // In production, only PostgreSQL is supported
  if (process.env.NODE_ENV === 'production') {
    if (!config.database.url) missing.push('DATABASE_URL');
  } else {
    // In development, either is acceptable
    if (!config.database.url && !config.database.path) {
      missing.push('DATABASE_URL or DATABASE_PATH');
    }
  }

  return missing;
}

// =============================================================================
// Vault Configuration Helpers (Sprint 71: Vault Transit Integration - CRIT-2)
// =============================================================================

/**
 * Check if Vault secrets management is enabled and configured
 */
export function isVaultEnabled(): boolean {
  return config.features.vaultEnabled && !!config.vault.addr && !!config.vault.token;
}

/**
 * Get Vault server address
 * Returns undefined if Vault is not configured
 */
export function getVaultAddr(): string | undefined {
  return config.vault.addr;
}

/**
 * Get Vault authentication token
 * SECURITY: Only use in secure contexts, never log or expose
 */
export function getVaultToken(): string | undefined {
  return config.vault.token;
}

/**
 * Get Vault namespace (for Vault Enterprise)
 * Returns undefined if namespace is not configured
 */
export function getVaultNamespace(): string | undefined {
  return config.vault.namespace;
}

/**
 * Get the default signing key name for Vault Transit
 */
export function getVaultSigningKeyName(): string {
  return config.vault.signingKeyName;
}

/**
 * Get Vault request timeout in milliseconds
 */
export function getVaultRequestTimeout(): number {
  return config.vault.requestTimeout;
}

/**
 * Get secret cache TTL in seconds
 * Secrets from Vault KV are cached for this duration
 */
export function getVaultSecretCacheTtl(): number {
  return config.vault.secretCacheTtl;
}

/**
 * Get missing Vault configuration
 * Returns list of missing configuration keys
 */
export function getMissingVaultConfig(): string[] {
  const missing: string[] = [];

  if (!config.vault.addr) missing.push('VAULT_ADDR');
  if (!config.vault.token) missing.push('VAULT_TOKEN');

  return missing;
}

/**
 * Vault configuration for creating clients/adapters
 */
export interface VaultClientConfig {
  addr: string;
  token: string;
  namespace?: string;
  signingKeyName: string;
  requestTimeout: number;
  secretCacheTtl: number;
}

/**
 * Get complete Vault client configuration
 * Throws if Vault is not properly configured
 */
export function getVaultClientConfig(): VaultClientConfig {
  if (!config.vault.addr || !config.vault.token) {
    throw new Error(
      'Vault is not configured. Set VAULT_ADDR and VAULT_TOKEN environment variables.'
    );
  }

  return {
    addr: config.vault.addr,
    token: config.vault.token,
    namespace: config.vault.namespace,
    signingKeyName: config.vault.signingKeyName,
    requestTimeout: config.vault.requestTimeout,
    secretCacheTtl: config.vault.secretCacheTtl,
  };
}
